Compiling Program: C:\DataFlex Projects\Foto\AppSrc\Foto.src
Memory Available: 7571488768
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.x64.pkd    (C:\Program Files\DataFlex 20.0\Pkg\dfallent.x64.pkd)
68480>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCJStandardCommandBarSystem.pkg)
68480>>>// these are all the packages used in a standard MDI menubar/toolbar system
68480>>>
68480>>>Use cCJCommandBarSystem.pkg
68480>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCJStandardMenuItemClasses.pkg)
68480>>>>>Use Dfpanel.pkg
68480>>>>>Use cCJCommandBarSystem.pkg
68480>>>>>Use LanguageText.pkg
68480>>>>>
68480>>>>>
68480>>>>>Class cCJUndoMenuItem is a cCJMenuItem
68481>>>>>    
68481>>>>>    Procedure Construct_Object
68483>>>>>        Forward Send Construct_Object
68485>>>>>        Set psCaption   to C_$CaptionUndo
68486>>>>>        Set psToolTip to C_$ToolTipUndo
68487>>>>>        Set psDescription to C_$DescUndo
68488>>>>>        Set psImage to "ActionUndo.ico"
68489>>>>>        Set pbActiveUpdate to True
68490>>>>>        Set psCategory to C_$CategoryEdit
68491>>>>>        Set psShortcut to C_$Key_Ctrl_Z
68492>>>>>    End_Procedure
68493>>>>>    
68493>>>>>    Procedure OnExecute Variant vCommandBarControl
68495>>>>>        Send Undo of (focus(Self))
68496>>>>>    End_Procedure
68497>>>>>    
68497>>>>>    Function IsEnabled Returns Boolean
68499>>>>>        Boolean bEnabled
68499>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
68500>>>>>        Function_Return bEnabled
68501>>>>>    End_Function
68502>>>>>    
68502>>>>>End_Class
68503>>>>>
68503>>>>>
68503>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
68504>>>>>    
68504>>>>>    Procedure Construct_Object
68506>>>>>        Forward Send Construct_Object
68508>>>>>        Set psCaption   to C_$CaptionDelete
68509>>>>>        Set psToolTip to C_$ToolTipDelete
68510>>>>>        Set psDescription to C_$DescDelete
68511>>>>>        Set psImage to "actionDelete.ico"
68512>>>>>        Set psShortcut to C_$Key_Delete
68513>>>>>        Set pbActiveUpdate to True
68514>>>>>        Set psCategory to C_$CategoryEdit
68515>>>>>    End_Procedure
68516>>>>>    
68516>>>>>    
68516>>>>>    Procedure OnExecute Variant vCommandBarControl
68518>>>>>        Send Delete of (focus(Self))
68519>>>>>    End_Procedure
68520>>>>>    
68520>>>>>    Function IsEnabled Returns Boolean
68522>>>>>        Boolean bEnabled
68522>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
68523>>>>>        Function_Return bEnabled
68524>>>>>    End_Function
68525>>>>>    
68525>>>>>End_Class
68526>>>>>
68526>>>>>
68526>>>>>Class cCJCutMenuItem is a cCJMenuItem
68527>>>>>    
68527>>>>>    Procedure Construct_Object
68529>>>>>        Forward Send Construct_Object
68531>>>>>        Set psCaption   to C_$CaptionCut
68532>>>>>        Set psToolTip to C_$TooltipCut
68533>>>>>        Set psDescription to C_$DescCut
68534>>>>>        Set psImage to "actionCut.ico"
68535>>>>>        Set psShortcut to C_$Key_Ctrl_X
68536>>>>>        Set pbActiveUpdate to True
68537>>>>>        Set psCategory to C_$CategoryEdit
68538>>>>>    End_Procedure
68539>>>>>    
68539>>>>>    
68539>>>>>    Procedure OnExecute Variant vCommandBarControl
68541>>>>>        Send Cut of (focus(Self))
68542>>>>>    End_Procedure
68543>>>>>    
68543>>>>>    Function IsEnabled Returns Boolean
68545>>>>>        Boolean bEnabled
68545>>>>>        Get CanCut of (Focus(Self)) to bEnabled
68546>>>>>        Function_Return bEnabled
68547>>>>>    End_Function
68548>>>>>    
68548>>>>>End_Class
68549>>>>>
68549>>>>>
68549>>>>>Class cCJCopyMenuItem is a cCJMenuItem
68550>>>>>    
68550>>>>>    Procedure Construct_Object
68552>>>>>        Forward Send Construct_Object
68554>>>>>        Set psCaption   to C_$CaptionCopy
68555>>>>>        Set psToolTip to C_$ToolTipCopy
68556>>>>>        Set psDescription to C_$DescCopy
68557>>>>>        Set psImage to "actionCopy.ico"
68558>>>>>        Set psShortcut to C_$Key_Ctrl_C
68559>>>>>        Set pbActiveUpdate to True
68560>>>>>        Set psCategory to C_$CategoryEdit
68561>>>>>    End_Procedure
68562>>>>>    
68562>>>>>    
68562>>>>>    Procedure OnExecute Variant vCommandBarControl
68564>>>>>        Send Copy of (focus(Self))
68565>>>>>    End_Procedure
68566>>>>>    
68566>>>>>    Function IsEnabled Returns Boolean
68568>>>>>        Boolean bEnabled
68568>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
68569>>>>>        Function_Return bEnabled
68570>>>>>    End_Function
68571>>>>>    
68571>>>>>End_Class
68572>>>>>
68572>>>>>
68572>>>>>Class cCJPasteMenuItem is a cCJMenuItem
68573>>>>>    
68573>>>>>    Procedure Construct_Object
68575>>>>>        Forward Send Construct_Object
68577>>>>>        Set psCaption   to C_$CaptionPaste
68578>>>>>        Set psToolTip to C_$ToolTipPaste
68579>>>>>        Set psDescription to C_$DescPaste
68580>>>>>        Set psImage to "actionPaste.ico"
68581>>>>>        Set pbActiveUpdate to True
68582>>>>>        Set psShortcut to C_$Key_Ctrl_V
68583>>>>>        Set psCategory to C_$CategoryEdit
68584>>>>>    End_Procedure
68585>>>>>    
68585>>>>>    
68585>>>>>    Procedure OnExecute Variant vCommandBarControl
68587>>>>>        Send Paste of (focus(Self))
68588>>>>>    End_Procedure
68589>>>>>    
68589>>>>>    Function IsEnabled Returns Boolean
68591>>>>>        Boolean bEnabled
68591>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
68592>>>>>        Function_Return bEnabled
68593>>>>>    End_Function
68594>>>>>    
68594>>>>>End_Class
68595>>>>>
68595>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
68596>>>>>    
68596>>>>>    Procedure Construct_Object
68598>>>>>        Forward Send Construct_Object
68600>>>>>        Set psCaption   to C_$CaptionSelectAll
68601>>>>>        Set psToolTip to C_$ToolTipSelectAll
68602>>>>>        Set psDescription to C_$DescSelectAll
68603>>>>>        Set pbActiveUpdate to True
68604>>>>>        Set psShortcut to C_$Key_Ctrl_A
68605>>>>>        Set psCategory to C_$CategoryEdit
68606>>>>>    End_Procedure
68607>>>>>    
68607>>>>>    
68607>>>>>    Procedure OnExecute Variant vCommandBarControl
68609>>>>>        Send Select_All of (focus(Self))
68610>>>>>    End_Procedure
68611>>>>>    
68611>>>>>    Function IsEnabled Returns Boolean
68613>>>>>        Boolean bEnabled
68613>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
68614>>>>>        Function_Return bEnabled
68615>>>>>    End_Function
68616>>>>>    
68616>>>>>End_Class
68617>>>>>
68617>>>>>
68617>>>>>Class cCJExitMenuItem is a cCJMenuItem
68618>>>>>    
68618>>>>>    Procedure Construct_Object
68620>>>>>        Forward Send Construct_Object
68622>>>>>        Set psCaption to C_$CaptionExit
68623>>>>>        Set psToolTip to C_$ToolTipExit
68624>>>>>        Set psDescription to C_$ToolTipExit
68625>>>>>        Set psShortcut to C_$Key_Alt_F4
68626>>>>>        Set psCategory to C_$CategoryFile
68627>>>>>    End_Procedure
68628>>>>>    
68628>>>>>    Procedure OnExecute Variant vCommandBarControl
68630>>>>>        Send Exit_Application of Desktop
68631>>>>>    End_Procedure
68632>>>>>    
68632>>>>>End_Class
68633>>>>>
68633>>>>>Class cCJHelpMenuItem is a cCJMenuItem
68634>>>>>    
68634>>>>>    Procedure Construct_Object
68636>>>>>        Forward Send Construct_Object
68638>>>>>        Set psCaption to C_$CaptionHelp
68639>>>>>        Set psDescription to C_$ToolTipHelp
68640>>>>>        Set psToolTip to C_$DescHelp
68641>>>>>        Set psImage to "ActionHelp.ico"
68642>>>>>        Set psShortcut to "F1"
68643>>>>>        Set psCategory to C_$CategoryHelp
68644>>>>>    End_Procedure
68645>>>>>    
68645>>>>>    Procedure OnExecute Variant vCommandBarControl
68647>>>>>        Send Help of (Focus(Self))
68648>>>>>    End_Procedure
68649>>>>>    
68649>>>>>End_Class
68650>>>>>
68650>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
68651>>>>>    
68651>>>>>    Procedure Construct_Object
68653>>>>>        Forward Send Construct_Object
68655>>>>>        Set psCaption to C_$CaptionAddStatusbar
68656>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
68657>>>>>        Set psDescription to  C_$DescAddStatusbar
68658>>>>>        Set psCategory to C_$CategoryWindow
68659>>>>>    End_Procedure
68660>>>>>    
68660>>>>>    Procedure OnExecute Variant vCommandBarControl
68662>>>>>        Handle hoCommandBars hoClientArea
68662>>>>>        Get CommandBarSystemObject to hoCommandBars
68663>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68664>>>>>        If hoClientArea Begin
68666>>>>>            // the clientarea's parent panel has message
68666>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
68667>>>>>        End
68667>>>>>>
68667>>>>>    End_Procedure
68668>>>>>    
68668>>>>>    Function IsChecked Returns Boolean
68670>>>>>        Boolean bOn
68670>>>>>        Handle hoCommandBars hoClientArea
68670>>>>>        Get CommandBarSystemObject to hoCommandBars
68671>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68672>>>>>        If hoClientArea Begin
68674>>>>>            // the clientarea's parent panel has message
68674>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
68675>>>>>        End
68675>>>>>>
68675>>>>>        Function_Return bOn
68676>>>>>    End_Function
68677>>>>>End_Class
68678>>>>>
68678>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
68679>>>>>    
68679>>>>>    Procedure Construct_Object
68681>>>>>        Forward Send Construct_Object
68683>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
68684>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
68685>>>>>        Set psDescription to C_$DescAutoArrangeIcons
68686>>>>>        Set psCategory to C_$CategoryWindow
68687>>>>>    End_Procedure
68688>>>>>    
68688>>>>>    Procedure OnExecute Variant vCommandBarControl
68690>>>>>        Handle hoCommandBars hoClientArea
68690>>>>>        Get CommandBarSystemObject to hoCommandBars
68691>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68692>>>>>        If hoClientArea Begin
68694>>>>>            // the clientarea's parent panel has message
68694>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
68695>>>>>        End
68695>>>>>>
68695>>>>>    End_Procedure
68696>>>>>    
68696>>>>>    Function IsChecked Returns Boolean
68698>>>>>        Boolean bOn
68698>>>>>        Handle hoCommandBars hoClientArea
68698>>>>>        Get CommandBarSystemObject to hoCommandBars
68699>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68700>>>>>        If hoClientArea Begin
68702>>>>>            // the clientarea's parent panel has message
68702>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
68703>>>>>        End
68703>>>>>>
68703>>>>>        Function_Return bOn
68704>>>>>    End_Function
68705>>>>>End_Class
68706>>>>>
68706>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
68707>>>>>    
68707>>>>>    Procedure Construct_Object
68709>>>>>        Forward Send Construct_Object
68711>>>>>        Set psCaption to C_$CaptionRestoreMenus
68712>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
68713>>>>>        Set psDescription to C_$DescRestoreMenus
68714>>>>>        Set psCategory to C_$CategoryWindow
68715>>>>>    End_Procedure
68716>>>>>    
68716>>>>>    Procedure OnExecute Variant vCommandBarControl
68718>>>>>        Handle hoCommandBars
68718>>>>>        Get CommandBarSystemObject to hoCommandBars
68719>>>>>        Send RestoreLayout of hoCommandBars
68720>>>>>    End_Procedure
68721>>>>>    
68721>>>>>End_Class
68722>>>>>
68722>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
68723>>>>>    
68723>>>>>    Procedure Construct_Object
68725>>>>>        Forward Send Construct_Object
68727>>>>>        Set psCaption to C_$CaptionCascade
68728>>>>>        Set psToolTip to C_$ToolTipCascade
68729>>>>>        Set psDescription to  C_$DescCascade
68730>>>>>        Set psImage to "ActionCascade.ico"
68731>>>>>        Set psCategory to C_$CategoryWindow
68732>>>>>    End_Procedure
68733>>>>>    
68733>>>>>    Procedure OnExecute Variant vCommandBarControl
68735>>>>>        Handle hoCommandBars hoClientArea
68735>>>>>        Get CommandBarSystemObject to hoCommandBars
68736>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68737>>>>>        If hoClientArea Begin
68739>>>>>            Send Cascade_Windows of hoClientArea
68740>>>>>        End
68740>>>>>>
68740>>>>>    End_Procedure
68741>>>>>End_Class
68742>>>>>
68742>>>>>Class cCJTileHorizontally is a cCJMenuItem
68743>>>>>    
68743>>>>>    Procedure Construct_Object
68745>>>>>        Forward Send Construct_Object
68747>>>>>        Set psCaption to C_$CaptionTileHorizontally
68748>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
68749>>>>>        Set psDescription to  C_$DescTileHorizontally
68750>>>>>        Set psImage to "ActionTileHorizontally.ico"
68751>>>>>        Set psCategory to C_$CategoryWindow
68752>>>>>    End_Procedure
68753>>>>>    
68753>>>>>    Procedure OnExecute Variant vCommandBarControl
68755>>>>>        Handle hoCommandBars hoClientArea
68755>>>>>        Get CommandBarSystemObject to hoCommandBars
68756>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68757>>>>>        If hoClientArea Begin
68759>>>>>            Send Tile_Windows_Horizontal of hoClientArea
68760>>>>>        End
68760>>>>>>
68760>>>>>    End_Procedure
68761>>>>>End_Class
68762>>>>>
68762>>>>>Class cCJTileVertically is a cCJMenuItem
68763>>>>>    
68763>>>>>    Procedure Construct_Object
68765>>>>>        Forward Send Construct_Object
68767>>>>>        Set psCaption to C_$CaptionTileVertically
68768>>>>>        Set psToolTip to C_$ToolTipTileVertically
68769>>>>>        Set psDescription to  C_$DescTileVertically
68770>>>>>        Set psImage to "ActionTileVertically.ico"
68771>>>>>        Set psCategory to C_$CategoryWindow
68772>>>>>    End_Procedure
68773>>>>>    
68773>>>>>    Procedure OnExecute Variant vCommandBarControl
68775>>>>>        Handle hoCommandBars hoClientArea
68775>>>>>        Get CommandBarSystemObject to hoCommandBars
68776>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68777>>>>>        If hoClientArea Begin
68779>>>>>            Send Tile_Windows_Vertical of hoClientArea
68780>>>>>        End
68780>>>>>>
68780>>>>>    End_Procedure
68781>>>>>End_Class
68782>>>>>
68782>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
68783>>>>>    
68783>>>>>    Procedure Construct_Object
68785>>>>>        Forward Send Construct_Object
68787>>>>>        Set psCaption to C_$CaptionMinimizeWindows
68788>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
68789>>>>>        Set psDescription to  C_$DescMinimizeWindows
68790>>>>>        Set psCategory to C_$CategoryWindow
68791>>>>>    End_Procedure
68792>>>>>    
68792>>>>>    Procedure OnExecute Variant vCommandBarControl
68794>>>>>        Handle hoCommandBars hoClientArea
68794>>>>>        Get CommandBarSystemObject to hoCommandBars
68795>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68796>>>>>        If hoClientArea Begin
68798>>>>>            // the clientarea's parent panel has message
68798>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
68799>>>>>        End
68799>>>>>>
68799>>>>>    End_Procedure
68800>>>>>End_Class
68801>>>>>
68801>>>>>
68801>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
68802>>>>>    
68802>>>>>    Procedure Construct_Object
68804>>>>>        Forward Send Construct_Object
68806>>>>>        Set psCaption to C_$CaptionRestoreWindows
68807>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
68808>>>>>        Set psDescription to  C_$DescRestoreWindows
68809>>>>>        Set psCategory to C_$CategoryWindow
68810>>>>>    End_Procedure
68811>>>>>    
68811>>>>>    Procedure OnExecute Variant vCommandBarControl
68813>>>>>        Handle hoCommandBars hoClientArea
68813>>>>>        Get CommandBarSystemObject to hoCommandBars
68814>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68815>>>>>        If hoClientArea Begin
68817>>>>>            // the clientarea's parent panel has message
68817>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
68818>>>>>        End
68818>>>>>>
68818>>>>>    End_Procedure
68819>>>>>End_Class
68820>>>>>
68820>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
68821>>>>>    
68821>>>>>    Procedure Construct_Object
68823>>>>>        Forward Send Construct_Object
68825>>>>>        Set psCaption to C_$CaptionArrangeIcons
68826>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
68827>>>>>        Set psDescription to  C_$DescArrangeIcons
68828>>>>>        Set psCategory to C_$CategoryWindow
68829>>>>>    End_Procedure
68830>>>>>    
68830>>>>>    Procedure OnExecute Variant vCommandBarControl
68832>>>>>        Handle hoCommandBars hoClientArea
68832>>>>>        Get CommandBarSystemObject to hoCommandBars
68833>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68834>>>>>        If hoClientArea Begin
68836>>>>>            Send Arrange_Icons of hoClientArea
68837>>>>>        End
68837>>>>>>
68837>>>>>    End_Procedure
68838>>>>>    
68838>>>>>End_Class
68839>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCJAboutMenuItem.pkg)
68839>>>>>Use cCJCommandBarSystem.pkg
68839>>>>>Use LanguageText.pkg
68839>>>>>
68839>>>>>// It is expected that if you use this class that you provide an about object that is
68839>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
68839>>>>>// because you may wish to create your own custom about package.
68839>>>>>
68839>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
68840>>>>>
68840>>>>>    Procedure Construct_Object
68842>>>>>        Forward Send Construct_Object
68844>>>>>        Set psCaption to C_$CaptionAbout
68845>>>>>        Set psDescription to C_$ToolTipAbout
68846>>>>>        Set psToolTip to C_$DescAbout
68847>>>>>        Set psImage to "ActionAbout.ico"
68848>>>>>        Set psCategory to C_$CategoryHelp
68849>>>>>    End_Procedure
68850>>>>>    
68850>>>>>    Procedure OnExecute Variant vCommandBarControl
68852>>>>>        Handle hoCommandBars hoClientArea
68852>>>>>        Get CommandBarSystemObject to hoCommandBars
68853>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
68854>>>>>        If hoClientArea Begin
68856>>>>>            Send Activate_About of hoClientArea
68857>>>>>        End
68857>>>>>>
68857>>>>>    End_Procedure
68858>>>>>
68858>>>>>End_Class
68859>>>>>
68859>>>>>
68859>>>Use cCJDeoMenuItemClasses.pkg
68859>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCJMDIWindowsMenuItem.pkg)
68859>>>>>Use cCJCommandBarSystem.pkg
68859>>>>>
68859>>>>>Register_Function Client_ID Returns Integer
68859>>>>>
68859>>>>>// only used by cCJMDIWIndowsMenuItem
68859>>>>>Class cCJMDIWindowItem is a cCJMenuItem
68860>>>>>    
68860>>>>>    Procedure Construct_Object
68862>>>>>        Forward Send Construct_Object
68864>>>>>        Property Handle phWindow 0 // object id of view
68865>>>>>        Set pbControlFlagNoMovable to True
68866>>>>>        Set pbActiveUpdate to True
68867>>>>>    End_Procedure
68868>>>>>    
68868>>>>>    Procedure OnExecute Variant vCommandBarControl
68870>>>>>        Handle hWindow
68870>>>>>        Get phWindow to hWindow
68871>>>>>        Send Activate_View of hWindow
68872>>>>>    End_Procedure
68873>>>>>    
68873>>>>>End_Class
68874>>>>>
68874>>>>>
68874>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
68875>>>>>    
68875>>>>>    Procedure Construct_Object
68877>>>>>        Forward Send Construct_Object
68879>>>>>        Property Handle[] phArrayOfWindows
68880>>>>>        Set peControlType to xtpControlPopup
68881>>>>>        Set psCategory to C_$CategoryWindow
68882>>>>>    End_Procedure
68883>>>>>    
68883>>>>>    // This adds MDI windows to the existing menu items.
68883>>>>>    // This removes any existing windows menus and always adds a new set to the end
68883>>>>>    
68883>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
68885>>>>>        Handle  hClientArea hView
68885>>>>>        String  sLabel
68885>>>>>        Integer i iWindows
68885>>>>>        Handle[] hArrayOfWindows
68886>>>>>        Variant vItem
68886>>>>>        
68886>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
68886>>>>>        // also assume that destroying an action removes all menu instances of that action
68886>>>>>        Get phArrayOfWindows to hArrayOfWindows
68887>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
68888>>>>>        For i from 0 to (iWindows-1)
68894>>>>>>
68894>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
68895>>>>>        Loop
68896>>>>>>
68896>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
68897>>>>>        
68897>>>>>        // Add all views to this menu. Create the action and add the item
68897>>>>>        Move 0 to i
68898>>>>>        Get Client_Id to hClientArea // object id of client area
68899>>>>>        If (hClientArea > 0) Begin
68901>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
68902>>>>>            While (hView <> 0)
68906>>>>>                If (Active_State(hView)) Begin
68908>>>>>                    // create the action
68908>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
68909>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
68910>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
68911>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
68912>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
68914>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
68915>>>>>                    End
68915>>>>>>
68915>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
68916>>>>>                    If (i=0) Begin
68918>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
68919>>>>>                    End
68919>>>>>>
68919>>>>>                    // Create a menu item for this action
68919>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
68920>>>>>                    Increment i
68921>>>>>                End
68921>>>>>>
68921>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
68922>>>>>            Loop
68923>>>>>>
68923>>>>>        End
68923>>>>>>
68923>>>>>        
68923>>>>>        Set phArrayOfWindows to hArrayOfWindows
68924>>>>>        
68924>>>>>    End_Procedure
68925>>>>>    
68925>>>>>End_Class
68926>
68926>Object oHtmlHelp is a cHtmlHelp
68928>End_Object
68929>
68929>Object oApplication is a cApplication
68931>    Set peHelpType to htHtmlHelp
68932>
68932>    Object oConnection is a cConnection
68934>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 20.0\Pkg\LoginEncryption.pkg)
68934>>>Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cLoginEncryption.pkg)
68934>>>>>Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cCryptographerEx.pkg)
68934>>>>>>>Use VdfBase.pkg
68934>>>>>>>
68934>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 20.0\Pkg\CryptographerConstants.pkg)
68934>>>>>>>>>//   Author  : Ulbe Stellema
68934>>>>>>>>>// Algorithm classes
68934>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
68934>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
68934>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
68934>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
68934>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
68934>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
68934>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
68934>>>>>>>>>
68934>>>>>>>>>// Algorithm types
68934>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
68934>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
68934>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
68934>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
68934>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
68934>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
68934>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
68934>>>>>>>>>
68934>>>>>>>>>// Generic sub-ids
68934>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
68934>>>>>>>>>
68934>>>>>>>>>// RSA sub-ids
68934>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
68934>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
68934>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
68934>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
68934>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
68934>>>>>>>>>
68934>>>>>>>>>// DSS sub-ids
68934>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
68934>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
68934>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
68934>>>>>>>>>
68934>>>>>>>>>// DES sub_ids
68934>>>>>>>>>Define ALG_SID_DES                      for 1
68934>>>>>>>>>Define ALG_SID_3DES                     for 3
68934>>>>>>>>>Define ALG_SID_DESX                     for 4
68934>>>>>>>>>Define ALG_SID_IDEA                     for 5
68934>>>>>>>>>Define ALG_SID_CAST                     for 6
68934>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
68934>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
68934>>>>>>>>>Define ALG_SID_3DES_112                 for 9
68934>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
68934>>>>>>>>>Define ALG_SID_RC5                      for 13
68934>>>>>>>>>Define ALG_SID_AES_128                  for 14
68934>>>>>>>>>Define ALG_SID_AES_192                  for 15
68934>>>>>>>>>Define ALG_SID_AES_256                  for 16
68934>>>>>>>>>Define ALG_SID_AES                      for 17
68934>>>>>>>>>
68934>>>>>>>>>// Fortezza sub-ids
68934>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
68934>>>>>>>>>Define ALG_SID_TEK                      for 11
68934>>>>>>>>>
68934>>>>>>>>>// RC2 sub-ids
68934>>>>>>>>>Define ALG_SID_RC2                      for 2
68934>>>>>>>>>
68934>>>>>>>>>// Stream cipher sub-ids
68934>>>>>>>>>Define ALG_SID_RC4                      for 1
68934>>>>>>>>>Define ALG_SID_SEAL                     for 2
68934>>>>>>>>>
68934>>>>>>>>>// Diffie-Hellman sub-ids
68934>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
68934>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
68934>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
68934>>>>>>>>>Define ALG_SID_KEA                      for 4
68934>>>>>>>>>
68934>>>>>>>>>// Hash sub ids
68934>>>>>>>>>Define ALG_SID_MD2                      for 1
68934>>>>>>>>>Define ALG_SID_MD4                      for 2
68934>>>>>>>>>Define ALG_SID_MD5                      for 3
68934>>>>>>>>>Define ALG_SID_SHA                      for 4
68934>>>>>>>>>Define ALG_SID_SHA1                     for 4
68934>>>>>>>>>Define ALG_SID_MAC                      for 5
68934>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
68934>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
68934>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
68934>>>>>>>>>Define ALG_SID_HMAC                     for 9
68934>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
68934>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
68934>>>>>>>>>Define ALG_SID_SHA_256                  for 12
68934>>>>>>>>>Define ALG_SID_SHA_384                  for 13
68934>>>>>>>>>Define ALG_SID_SHA_512                  for 14
68934>>>>>>>>>
68934>>>>>>>>>// secure channel sub ids
68934>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
68934>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
68934>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
68934>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
68934>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
68934>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
68934>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
68934>>>>>>>>>
68934>>>>>>>>>// algorithm identifier definitions
68934>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
68934>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
68934>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
68934>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
68934>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
68934>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
68934>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
68934>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
68934>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
68934>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
68934>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
68934>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
68934>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
68934>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
68934>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
68934>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
68934>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
68934>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
68934>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
68934>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
68934>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
68934>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
68934>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
68934>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
68934>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
68934>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
68934>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
68934>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
68934>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
68934>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
68934>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
68934>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
68934>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
68934>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
68934>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
68934>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
68934>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
68934>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
68934>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
68934>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
68934>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
68934>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
68934>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
68934>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
68934>>>>>>>>>
68934>>>>>>>>>// Providers
68934>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
68934>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
68934>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
68934>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
68934>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
68934>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
68934>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
68934>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
68934>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
68934>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
68934>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
68934>>>>>>>>>
68934>>>>>>>>>// dwFlags definitions for CryptAcquireContext
68934>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
68934>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
68934>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
68934>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
68934>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
68934>>>>>>>>>
68934>>>>>>>>>// dwFlag definitions for CryptGenKey
68934>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
68934>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
68934>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
68934>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
68934>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
68934>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
68934>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
68934>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
68934>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
68934>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
68934>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
68934>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
68934>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
68934>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
68934>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
68934>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
68934>>>>>>>>>
68934>>>>>>>>>// Provider types
68934>>>>>>>>>Define PROV_RSA_FULL                    for 1
68934>>>>>>>>>Define PROV_RSA_SIG                     for 2
68934>>>>>>>>>Define PROV_DSS                         for 3
68934>>>>>>>>>Define PROV_FORTEZZA                    for 4
68934>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
68934>>>>>>>>>Define PROV_SSL                         for 6
68934>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
68934>>>>>>>>>Define PROV_DSS_DH                      for 13
68934>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
68934>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
68934>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
68934>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
68934>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
68934>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
68934>>>>>>>>>Define PROV_RNG                         for 21
68934>>>>>>>>>Define PROV_INTEL_SEC                   for 22
68934>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
68934>>>>>>>>>Define PROV_RSA_AES                     for 24
68934>>>>>>>>>
68934>>>>>>>>>// KP_MODE
68934>>>>>>>>>// KP_MODE
68934>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
68934>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
68934>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
68934>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
68934>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
68934>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
68934>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
68934>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
68934>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
68934>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
68934>>>>>>>>>
68934>>>>>>>>>// dwParam definitions for CryptGetKeyParam
68934>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
68934>>>>>>>>>Define KP_SALT                          for 2       // Salt value
68934>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
68934>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
68934>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
68934>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
68934>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
68934>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
68934>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
68934>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
68934>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
68934>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
68934>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
68934>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
68934>>>>>>>>>Define KP_Y                             for 15      // Y value
68934>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
68934>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
68934>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
68934>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
68934>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
68934>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
68934>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
68934>>>>>>>>>Define KP_RP                            for 23
68934>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
68934>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
68934>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
68934>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
68934>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
68934>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
68934>>>>>>>>>Define KP_KEYVAL                        for 30
68934>>>>>>>>>Define KP_ADMIN_PIN                     for 31
68934>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
68934>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
68934>>>>>>>>>Define KP_PREHASH                       for 34
68934>>>>>>>>>Define KP_ROUNDS                        for 35
68934>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
68934>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
68934>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
68934>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
68934>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
68934>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
68934>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
68934>>>>>>>>>
68934>>>>>>>>>// dwParam definitions for CryptGetHashParam
68934>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
68934>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
68934>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
68934>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
68934>>>>>>>>>
68934>>>>>>>>>// key BLOB types
68934>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
68934>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
68934>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
68934>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
68934>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
68934>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
68934>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
68934>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
68934>>>>>>>>>
68934>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
68934>>>>>>>>>
68934>>>>>>>>>// KP_PADDING
68934>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
68934>>>>>>>>>Define RANDOM_PADDING                   for 2
68934>>>>>>>>>Define ZERO_PADDING                     for 3
68934>>>>>>>>>
68934>>>>>>>>>//  Structure cryptimportkey
68934>>>>>>>>>Struct PUBLICKEYSTRUC
68934>>>>>>>>>    UChar    bType
68934>>>>>>>>>    UChar    bVersion
68934>>>>>>>>>    UShort   reserved
68934>>>>>>>>>    UInteger aiKeyAlg
68934>>>>>>>>>End_Struct
68934>>>>>>>>>
68934>>>>>>>>>Struct tPLAINTEXTKEYBLOB
68934>>>>>>>>>    PUBLICKEYSTRUC hdr
68934>>>>>>>>>    PUBLICKEYSTRUC hdr
68934>>>>>>>>>    UInteger       dwKeySize
68934>>>>>>>>>//    UChar[]        rgbKeyData
68934>>>>>>>>>End_Struct
68934>>>>>>>>>
68934>>>>>>>>>
68934>>>>>>>>>
68934>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
68934>>>>>>>>>Struct HMAC_INFO
68934>>>>>>>>>    UInteger HashAlgid
68934>>>>>>>>>    Pointer pbInnerString
68934>>>>>>>>>    DWord cbInnerString
68934>>>>>>>>>    Pointer pbOuterString
68934>>>>>>>>>    DWord cbOuterString
68934>>>>>>>>>End_Struct
68934>>>>>>>>>
68934>>>>>>>>>Struct BLOBHEADER
68934>>>>>>>>>    UChar   bType
68934>>>>>>>>>    UChar   bVersion
68934>>>>>>>>>    Short   reserved
68934>>>>>>>>>    Integer aiKeyAlg
68934>>>>>>>>>End_Struct
68934>>>>>>>>>
68934>>>>>>>>>Struct CryptoBlob
68934>>>>>>>>>    BLOBHEADER  header
68934>>>>>>>>>    BLOBHEADER  header
68934>>>>>>>>>    Integer     cbKeySize
68934>>>>>>>>>    UChar[32]   rgbKeyData
68934>>>>>>>>>End_Struct
68934>>>>>>>>>
68934>>>>>>>>>
68934>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
68934>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
68935>>>>>>>>>
68935>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
68935>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
68937>>>>>>>>>    
68937>>>>>>>>>    Boolean bResult
68937>>>>>>>>>    UWide   uwContainer uwProvider
68937>>>>>>>>>    UWide   uwContainer uwProvider
68937>>>>>>>>>
68937>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
68938>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
68939>>>>>>>>>    
68939>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
68940>>>>>>>>>
68940>>>>>>>>>    Function_Return bResult
68941>>>>>>>>>End_Function
68942>>>>>>>>>
68942>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
68943>>>>>>>>>
68943>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
68944>>>>>>>>>
68944>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
68945>>>>>>>>>
68945>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
68946>>>>>>>>>
68946>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
68947>>>>>>>>>
68947>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
68948>>>>>>>>>
68948>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
68949>>>>>>>>>
68949>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
68950>>>>>>>>>
68950>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
68951>>>>>>>>>    
68951>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
68952>>>>>>>>>
68952>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
68953>>>>>>>>>
68953>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
68954>>>>>>>>>
68954>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
68955>>>>>>>>>    
68955>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
68956>>>>>>>>>    
68956>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
68957>>>>>>>>>    
68957>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
68958>>>>>>>
68958>>>>>>>Class cCryptographerEx is a cObject
68959>>>>>>>    
68959>>>>>>>    Procedure Construct_Object
68961>>>>>>>        Forward Send Construct_Object
68963>>>>>>>        
68963>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
68964>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
68965>>>>>>>        Property Integer    piCipher    CALG_RC4
68966>>>>>>>        Property Integer    piHash      CALG_MD5
68967>>>>>>>        
68967>>>>>>>        // Private properties
68967>>>>>>>        Property Handle     Private_phProv
68968>>>>>>>        
68968>>>>>>>        // Block cipher properties
68968>>>>>>>        Property UChar[]    paKey
68969>>>>>>>        Property UChar[]    paIV
68970>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
68971>>>>>>>        Property Integer    piKeyType       CALG_AES_256
68972>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
68973>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
68974>>>>>>>        Property Integer    piBlockSize     16
68975>>>>>>>    End_Procedure
68976>>>>>>>    
68976>>>>>>>    
68976>>>>>>>    // Acquire key container handle
68976>>>>>>>    Function AcquireContext Returns Handle
68978>>>>>>>        Integer iProvider
68978>>>>>>>        WString wProvider
68978>>>>>>>        Handle hProv
68978>>>>>>>        Boolean bOk
68978>>>>>>>        Pointer pProv
68978>>>>>>>        
68978>>>>>>>        Move 0 to hProv
68979>>>>>>>        Get piProvider to iProvider
68980>>>>>>>        Get psProvider to wProvider
68981>>>>>>>        
68981>>>>>>>        //  Determine address to be passed as provider
68981>>>>>>>        If (Trim(wProvider) <> "") Begin
68983>>>>>>>            Move (AddressOf(wProvider)) to pProv
68984>>>>>>>        End
68984>>>>>>>>
68984>>>>>>>        Else Begin
68985>>>>>>>            Move 0 to pProv
68986>>>>>>>        End
68986>>>>>>>>
68986>>>>>>>        
68986>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
68986>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
68987>>>>>>>        If (not(bOk) or hProv = 0) Begin
68989>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
68990>>>>>>>        End
68990>>>>>>>>
68990>>>>>>>        
68990>>>>>>>        If (not(bOk) or hProv = 0) Begin
68992>>>>>>>            // Fallback to original
68992>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
68993>>>>>>>            
68993>>>>>>>            If (not(bOk) or hProv = 0) Begin
68995>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
68996>>>>>>>            End
68996>>>>>>>>
68996>>>>>>>        End
68996>>>>>>>>
68996>>>>>>>        Set Private_phProv to hProv
68997>>>>>>>        
68997>>>>>>>        Function_Return hProv
68998>>>>>>>    End_Function
68999>>>>>>>    
68999>>>>>>>    // Releases key container handle
68999>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
69001>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
69002>>>>>>>    End_Function
69003>>>>>>>    
69003>>>>>>>    // Creates hash object
69003>>>>>>>    Function CreateHash Handle hProv Returns Handle
69005>>>>>>>        Integer iAlgorithm
69005>>>>>>>        Handle hHash
69005>>>>>>>        Boolean bOk
69005>>>>>>>        
69005>>>>>>>        Move 0 to hHash
69006>>>>>>>        Get piHash to iAlgorithm
69007>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
69008>>>>>>>        
69008>>>>>>>        Function_Return hHash
69009>>>>>>>    End_Function
69010>>>>>>>    
69010>>>>>>>    // Destroys the hash object
69010>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
69012>>>>>>>        Function_Return (CryptDestroyHash(hHash))
69013>>>>>>>    End_Function
69014>>>>>>>    
69014>>>>>>>    // Adds data to hash object
69014>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
69016>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
69017>>>>>>>    End_Function
69018>>>>>>>    
69018>>>>>>>    // Generates session key
69018>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
69020>>>>>>>        Integer iAlgorithm
69020>>>>>>>        Handle hKey
69020>>>>>>>        Boolean bOk
69020>>>>>>>        
69020>>>>>>>        Move 0 to hKey
69021>>>>>>>        Get piCipher to iAlgorithm
69022>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
69023>>>>>>>        
69023>>>>>>>        Function_Return hKey
69024>>>>>>>    End_Function
69025>>>>>>>    
69025>>>>>>>    // Imports a plain text key
69025>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
69027>>>>>>>        tPLAINTEXTKEYBLOB blobhead
69027>>>>>>>        tPLAINTEXTKEYBLOB blobhead
69027>>>>>>>        Boolean   bSuccess
69027>>>>>>>        Handle    hKey
69027>>>>>>>        Integer   iHeadSize iKeySize
69027>>>>>>>        UChar[]   ucaKeyblob
69028>>>>>>>        Integer iVoid
69028>>>>>>>        
69028>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
69029>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
69030>>>>>>>        
69030>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
69031>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
69032>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
69033>>>>>>>        Move iKeySize           to blobhead.dwKeySize
69034>>>>>>>        
69034>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
69035>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
69036>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
69037>>>>>>>        
69037>>>>>>>        Move 0 to hKey
69038>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
69039>>>>>>>        If (not(bSuccess)) Begin
69041>>>>>>>            Move (ShowLastError()) to iVoid
69042>>>>>>>        End
69042>>>>>>>>
69042>>>>>>>        
69042>>>>>>>        Function_Return hKey
69043>>>>>>>    End_Function
69044>>>>>>>    
69044>>>>>>>    // Destroys the key
69044>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
69046>>>>>>>        Function_Return (CryptDestroyKey(hKey))
69047>>>>>>>    End_Function
69048>>>>>>>    
69048>>>>>>>    // Retrieves key data
69048>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
69050>>>>>>>        Integer iBuffer iLen
69050>>>>>>>        Boolean bOk
69050>>>>>>>        
69050>>>>>>>        Move (SizeOfType(Integer)) to iLen
69051>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
69052>>>>>>>        Function_Return iBuffer
69053>>>>>>>    End_Function
69054>>>>>>>    
69054>>>>>>>    // Retrieves a hash value
69054>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
69056>>>>>>>        UChar[] ucHash
69057>>>>>>>        Integer liResult
69057>>>>>>>        DWord   dwDataLen
69057>>>>>>>        
69057>>>>>>>        Move 0 to dwDataLen
69058>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
69059>>>>>>>        If (liResult = 0) ;            Function_Return ""
69062>>>>>>>        
69062>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
69063>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
69064>>>>>>>        If (liResult = 0) ;            Function_Return ""
69067>>>>>>>        
69067>>>>>>>        Function_Return ucHash
69068>>>>>>>    End_Function
69069>>>>>>>
69069>>>>>>>    // Encrypts data
69069>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
69071>>>>>>>        Handle hProv hHash hKey
69071>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
69071>>>>>>>        Boolean bOk
69071>>>>>>>        
69071>>>>>>>        Get AcquireContext to hProv
69072>>>>>>>        If (hProv) Begin
69074>>>>>>>            Get CreateHash hProv to hHash
69075>>>>>>>            If (hHash) Begin
69077>>>>>>>                Get HashData hHash ucPassword to bOk
69078>>>>>>>                If (bOk) Begin
69080>>>>>>>                    Get piCipher to iAlgorithm
69081>>>>>>>                    Get DeriveKey hProv hHash to hKey
69082>>>>>>>                End
69082>>>>>>>>
69082>>>>>>>                Get DestroyHash hHash to bOk
69083>>>>>>>            End
69083>>>>>>>>
69083>>>>>>>            
69083>>>>>>>            If (hKey) Begin
69085>>>>>>>                //  First call to determine resulting data size
69085>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
69086>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
69087>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
69088>>>>>>>                
69088>>>>>>>                //  Reserve space in string
69088>>>>>>>                If (iDataLen < iCipherLen) Begin
69090>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
69091>>>>>>>                End
69091>>>>>>>>
69091>>>>>>>                
69091>>>>>>>                //  Call to really decrypt
69091>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
69092>>>>>>>                //If (not(bOk)) Begin
69092>>>>>>>                //Move "" to sData
69092>>>>>>>                //Move (GetLastError()) to iErr
69092>>>>>>>                //End
69092>>>>>>>                
69092>>>>>>>                Get DestroyKey hKey to bOk
69093>>>>>>>            End 
69093>>>>>>>>
69093>>>>>>>            Get ReleaseContext hProv to bOk
69094>>>>>>>        End 
69094>>>>>>>>
69094>>>>>>>        Function_Return ucData
69095>>>>>>>    End_Function
69096>>>>>>>    
69096>>>>>>>    // Decrypts data
69096>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
69098>>>>>>>        Handle hProv hHash hKey
69098>>>>>>>        Integer iAlgorithm iDataLen
69098>>>>>>>        Boolean bOk
69098>>>>>>>        
69098>>>>>>>        Get AcquireContext to hProv
69099>>>>>>>        If (hProv) Begin
69101>>>>>>>            Get CreateHash hProv to hHash
69102>>>>>>>            If (hHash) Begin
69104>>>>>>>                Get HashData hHash ucPassword to bOk
69105>>>>>>>                If (bOk) Begin
69107>>>>>>>                    Get piCipher to iAlgorithm
69108>>>>>>>                    Get DeriveKey hProv hHash to hKey
69109>>>>>>>                End
69109>>>>>>>>
69109>>>>>>>                Get DestroyHash hHash to bOk
69110>>>>>>>            End
69110>>>>>>>>
69110>>>>>>>            
69110>>>>>>>            If (hKey) Begin
69112>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
69113>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
69114>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
69114>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
69116>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
69117>>>>>>>                End
69117>>>>>>>>
69117>>>>>>>                
69117>>>>>>>                Get DestroyKey hKey to bOk
69118>>>>>>>            End
69118>>>>>>>>
69118>>>>>>>            Get ReleaseContext hProv to bOk
69119>>>>>>>        End
69119>>>>>>>>
69119>>>>>>>        Function_Return ucData
69120>>>>>>>    End_Function
69121>>>>>>>    
69121>>>>>>>    // Creates a key
69121>>>>>>>    Function CreateKey Handle hProv Returns Handle
69123>>>>>>>        Integer iAlg iType iByte iLength iSize
69123>>>>>>>        CryptoBlob keyBlob
69123>>>>>>>        CryptoBlob keyBlob
69123>>>>>>>        Boolean bOk
69123>>>>>>>        Handle hKey
69123>>>>>>>        UChar[] aKey
69124>>>>>>>
69124>>>>>>>        Get paKey to aKey
69125>>>>>>>        Get piKeyAlg to iAlg
69126>>>>>>>        Get piKeyType to iType
69127>>>>>>>        Move iAlg                   to keyBlob.header.bType
69128>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
69129>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
69130>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
69131>>>>>>>        
69131>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
69132>>>>>>>        For iByte from 0 to iLength
69138>>>>>>>>
69138>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
69139>>>>>>>        Loop
69140>>>>>>>>
69140>>>>>>>        
69140>>>>>>>        Move 0 to hKey
69141>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
69142>>>>>>>        Function_Return hKey
69143>>>>>>>    End_Function
69144>>>>>>>    
69144>>>>>>>    // Sets the key parameters
69144>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
69146>>>>>>>        Integer iPadding iMode
69146>>>>>>>        Boolean bOk
69146>>>>>>>        UChar[] aIV
69147>>>>>>>        
69147>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
69147>>>>>>>        //For iByte from 0 to iLength
69147>>>>>>>        //    Move iByte to aIV[iByte]
69147>>>>>>>        //Loop
69147>>>>>>>
69147>>>>>>>        // Set initialization vector
69147>>>>>>>        Get paIV to aIV
69148>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
69149>>>>>>>        If (bOk) Begin
69151>>>>>>>            // Set padding
69151>>>>>>>            Get piKeyPadding to iPadding
69152>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
69153>>>>>>>            If (bOk) Begin
69155>>>>>>>                // Set move
69155>>>>>>>                Get piKeyMode to iMode
69156>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
69157>>>>>>>            End
69157>>>>>>>>
69157>>>>>>>        End
69157>>>>>>>>
69157>>>>>>>        Function_Return bOk        
69158>>>>>>>    End_Function
69159>>>>>>>    
69159>>>>>>>    // Encrypts using block cipher
69159>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
69161>>>>>>>        Handle hProv hKey
69161>>>>>>>        Integer iLen iSize iBlocks
69161>>>>>>>        Boolean bOk
69161>>>>>>>        
69161>>>>>>>        Get AcquireContext to hProv
69162>>>>>>>        If (hProv) Begin
69164>>>>>>>            // Create key
69164>>>>>>>            Get CreateKey hProv to hKey
69165>>>>>>>            If (hKey) Begin
69167>>>>>>>                Get SetKeyParameters hKey to bOk
69168>>>>>>>                If (bOk) Begin
69170>>>>>>>                    // Buffer for block ciphers can be up to block length larger
69170>>>>>>>                    Get piBlockSize to iSize
69171>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
69172>>>>>>>                    
69172>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
69173>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
69174>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
69175>>>>>>>                End
69175>>>>>>>>
69175>>>>>>>                Get DestroyKey hKey to bOk
69176>>>>>>>            End
69176>>>>>>>>
69176>>>>>>>            Get ReleaseContext hProv to bOk
69177>>>>>>>        End
69177>>>>>>>>
69177>>>>>>>        Function_Return ucData
69178>>>>>>>    End_Function
69179>>>>>>>    
69179>>>>>>>    // Decrypts using block cipher
69179>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
69181>>>>>>>        Handle hProv hKey
69181>>>>>>>        Integer iLen
69181>>>>>>>        Boolean bOk
69181>>>>>>>        
69181>>>>>>>        Get AcquireContext to hProv
69182>>>>>>>        If (hProv) Begin
69184>>>>>>>            // Create key
69184>>>>>>>            Get CreateKey hProv to hKey
69185>>>>>>>            If (hKey) Begin
69187>>>>>>>                Get SetKeyParameters hKey to bOk
69188>>>>>>>                If (bOk) Begin
69190>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
69191>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
69192>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
69193>>>>>>>                End
69193>>>>>>>>
69193>>>>>>>                Get DestroyKey hKey to bOk
69194>>>>>>>            End
69194>>>>>>>>
69194>>>>>>>            Get ReleaseContext hProv to bOk
69195>>>>>>>        End
69195>>>>>>>>
69195>>>>>>>        Function_Return ucData
69196>>>>>>>    End_Function
69197>>>>>>>    
69197>>>>>>>    
69197>>>>>>>    //  Generates random data.
69197>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
69199>>>>>>>        Handle hProv
69199>>>>>>>        UChar[] uaResult
69200>>>>>>>        Boolean bRes
69200>>>>>>>        
69200>>>>>>>        Get AcquireContext to hProv
69201>>>>>>>        
69201>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
69202>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
69203>>>>>>>        
69203>>>>>>>        Get ReleaseContext hProv to bRes
69204>>>>>>>        
69204>>>>>>>        Function_Return uaResult
69205>>>>>>>    End_Function
69206>>>>>>>    
69206>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
69206>>>>>>>    Function GenerateRandomString Integer iLength Returns String
69208>>>>>>>        String sResult
69208>>>>>>>        UChar[] ucData
69209>>>>>>>        Pointer pBase64
69209>>>>>>>        Integer iVoid
69209>>>>>>>        
69209>>>>>>>        Get GenerateRandom iLength to ucData
69210>>>>>>>        
69210>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
69211>>>>>>>        Move (PointerToString(pBase64)) to sResult
69212>>>>>>>        Move (Free(pBase64)) to iVoid
69213>>>>>>>        
69213>>>>>>>        Function_Return (Left(sResult, iLength))
69214>>>>>>>    End_Function
69215>>>>>>>    
69215>>>>>>>End_Class
69216>>>>>
69216>>>>>Class cLoginEncryption is a cObject
69217>>>>>    
69217>>>>>    Procedure Construct_Object
69219>>>>>        Forward Send Construct_Object
69221>>>>>        // this must be set to a multi (40ish) character random key
69221>>>>>        Property String psEncryptPassword ""
69222>>>>>        
69222>>>>>        Object oDataCrypter is a cCryptographerEx
69224>>>>>            Set piHash to CALG_SHA_256
69225>>>>>            Set piCipher to CALG_AES_256
69226>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
69227>>>>>            Set piProvider to PROV_RSA_AES
69228>>>>>        End_Object
69229>>>>>    End_Procedure
69230>>>>>    
69230>>>>>    // This can be augmented to return a password encryption key using any
69230>>>>>    // hidden mechanism desired.
69230>>>>>    Function GetEncryptionPassword Returns String
69232>>>>>        String sPassword
69232>>>>>        Get psEncryptPassword to sPassword
69233>>>>>        Function_Return sPassword
69234>>>>>    End_Function
69235>>>>>    
69235>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
69235>>>>>    //
69235>>>>>    // Params:
69235>>>>>    //   sPlainText     String to encrypt.
69235>>>>>    // Returns:
69235>>>>>    //   Base64 encoded hash.
69235>>>>>    Function EncryptPassword String sPlainText Returns String
69237>>>>>        String sEncryptPassword sBase64
69237>>>>>        UChar[] ucBinary
69238>>>>>        Pointer pBase64
69238>>>>>        Integer iVoid
69238>>>>>        
69238>>>>>        //  Encrypt Key
69238>>>>>        Get GetEncryptionPassword to sEncryptPassword
69239>>>>>        If (sEncryptPassword = "") Begin
69241>>>>>            Error DFERR_PROGRAM "No encryption password set"
69242>>>>>>
69242>>>>>        End
69242>>>>>>
69242>>>>>        
69242>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
69243>>>>>        
69243>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
69245>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
69246>>>>>>
69246>>>>>            Function_Return ""
69247>>>>>        End
69247>>>>>>
69247>>>>>        
69247>>>>>        //  Encode binary hash to Base64
69247>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
69248>>>>>        Move (PointerToString(pBase64)) to sBase64
69249>>>>>        Move (Free(pBase64)) to iVoid
69250>>>>>        
69250>>>>>        Function_Return sBase64
69251>>>>>    End_Function
69252>>>>>    
69252>>>>>    
69252>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
69252>>>>>    //
69252>>>>>    // Params:
69252>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
69252>>>>>    // Returns:
69252>>>>>    //   Readable plain text password
69252>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
69254>>>>>        String sEncryptPassword
69254>>>>>        UChar[] ucBinary ucPlain
69256>>>>>        Boolean bIsHex
69256>>>>>        Integer iLen iVoid
69256>>>>>        Pointer pBinary
69256>>>>>        
69256>>>>>        If (sBase64EncryptedPassword <> "") Begin
69258>>>>>            //  Decode from Base64
69258>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
69259>>>>>            
69259>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
69260>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
69261>>>>>                        
69261>>>>>            Move (Free(pBinary)) to iVoid
69262>>>>>            
69262>>>>>            //  Encrypted binary hash to string
69262>>>>>            Get GetEncryptionPassword to sEncryptPassword
69263>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
69264>>>>>        End
69264>>>>>>
69264>>>>>        
69264>>>>>        Function_Return (UCharArrayToString(ucPlain))
69265>>>>>    End_Function
69266>>>>>End_Class
69267>>>
69267>>>Object oLoginEncryption is a cLoginEncryption
69269>>>
69269>>>    // this must be created in your appsrc directory and must contain an encryption
69269>>>    // key that is set to psEncryptPassword. It will look something like this
69269>>>    //
69269>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
69269>>>    //  
Including file: LoginEncryptionKey.inc    (C:\DataFlex Projects\Foto\AppSrc\LoginEncryptionKey.inc)
69269>>>>// Studio generated login encryption key
69269>>>>Set psEncryptPassword to "wnjamz/|jF6cQ56~b>CEi[m&:^t1%uylQW3OI,`("
69270>>>>
69270>>>    
69270>>>    // use this to register this object to your cConnection Object. This object
69270>>>    // must be created after the cConnection object
69270>>>    Move Self to ghoLoginEncryption
69271>>>End_Object
69272>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 20.0\Pkg\DatabaseLoginDialog.dg)
69272>>>
69272>>>Use Windows.pkg
69272>>>Use cConnection.pkg
69272>>>Use dfLine.pkg
69272>>>
69272>>>Object oDatabaseLoginDialog is a ModalPanel
69274>>>    Set Label to "Database Login"
69275>>>    Set Location to 2 2
69276>>>    Set Size to 110 211
69277>>>    
69277>>>    Property String psId
69279>>>    Property Boolean pbOk False
69281>>>    Property Boolean pbChanged False
69283>>>    Property Boolean pbAllowRemember True
69285>>>    
69285>>>    // this registers this object with the cConnection object.
69285>>>    Move Self to ghoLoginConnectDialog
69286>>>    
69286>>>    Object oUserIDForm is a Form
69288>>>        Set Label to "User Name"
69289>>>        Set Size to 12 85
69290>>>        Set Location to 34 79
69291>>>        Set Label_Col_Offset to 64
69292>>>        Set peAnchors to anTopLeftRight
69293>>>    End_Object
69294>>>    
69294>>>    Object oPwdForm is a Form
69296>>>        Set Size to 12 85
69297>>>        Set Location to 49 79
69298>>>        Set Label_Col_Offset to 64
69299>>>        Set Password_State to True
69300>>>        Set peAnchors to anTopLeftRight
69301>>>        Set Label to "Password"
69302>>>    End_Object
69303>>>    
69303>>>    Object oTrustedConnection is a CheckBox
69305>>>        Set Size to 10 50
69306>>>        Set Location to 65 79
69307>>>        Set Label to "Trusted Connection"
69308>>>    End_Object
69309>>>    
69309>>>    Object oRemember is a CheckBox
69311>>>        Set Size to 10 50
69312>>>        Set Location to 79 14
69313>>>        Set Label to "Remember and don't ask again"
69314>>>        Set Checked_State to True
69315>>>    End_Object
69316>>>    
69316>>>    Object oLogin_btn is a Button
69318>>>        Set Label to "&Login"
69319>>>        Set Location to 92 102
69320>>>        Set peAnchors to anBottomRight
69321>>>        Set Default_State to True
69322>>>        
69322>>>        Procedure OnClick
69325>>>            Boolean bTrust
69325>>>            String sUser sPwd sConn sErr sId
69325>>>            Integer iError
69325>>>            Get psId to sId
69326>>>            Get Value of oUserIDForm to sUser
69327>>>            Get Value of oPwdForm to sPwd
69328>>>            Get Checked_State of oTrustedConnection to bTrust
69329>>>            
69329>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
69330>>>            If (iError=0) Begin
69332>>>                Set pbOk to True
69333>>>                Set pbChanged to True
69334>>>                Send Close_Panel
69335>>>            End
69335>>>>
69335>>>            Else Begin
69336>>>                Get psErrorText of ghoConnection to sErr
69337>>>                Send UserError sErr "Login Error"
69338>>>            End
69338>>>>
69338>>>        End_Procedure
69339>>>    End_Object
69340>>>    
69340>>>    Object oCancel_btn is a Button
69342>>>        Set Label to "&Cancel"
69343>>>        Set Location to 92 157
69344>>>        Set peAnchors to anBottomRight
69345>>>        
69345>>>        Procedure OnClick
69348>>>            Send Close_Panel
69349>>>        End_Procedure
69350>>>    End_Object
69351>>>    
69351>>>    Object oConnectionIdInfo is a TextBox
69353>>>        Set Size to 10 50
69354>>>        Set Location to 4 14
69355>>>        Set Label to 'Connection Id='
69356>>>    End_Object
69357>>>    
69357>>>    Object oConnectionServerInfo is a TextBox
69359>>>        Set Size to 10 50
69360>>>        Set Location to 16 14
69361>>>        Set Label to 'Server'
69362>>>    End_Object
69363>>>    
69363>>>    Object oLineControl1 is a LineControl
69365>>>        Set Size to 2 202
69366>>>        Set Location to 29 5
69367>>>    End_Object
69368>>>    
69368>>>    Function LoginConnectIdDialog String sId Returns Boolean
69371>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
69371>>>        String sUser sPwd sDescription
69371>>>        tConnection Connect
69371>>>        tConnection Connect
69371>>>        
69371>>>        Get pbAllowRemember to bAllowRemember
69372>>>        
69372>>>        
69372>>>        If not bAllowRemember Begin
69374>>>            Set Enabled_State of oRemember to bRemember
69375>>>            Set Visible_State of oRemember to bRemember
69376>>>        End
69376>>>>
69376>>>        
69376>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
69377>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
69378>>>        Set Value of oConnectionServerInfo to Connect.sString
69379>>>        
69379>>>        Set psId to sId
69380>>>        Set pbOk to False
69381>>>        Set pbChanged to False
69382>>>        Set Value of oUserIDForm to Connect.sUID
69383>>>        Set Value of oPwdForm to ""
69384>>>        
69384>>>        Send Popup
69385>>>        
69385>>>        Get pbOk to bOk
69386>>>        Get pbChanged to bChanged
69387>>>        If (bChanged and bOk) Begin
69389>>>            If bAllowRemember Begin
69391>>>                Get Checked_State of oRemember to bRemember
69392>>>                If bRemember Begin
69394>>>                    Get Checked_State of oTrustedConnection to bTrusted
69395>>>                    If not (bTrusted) Begin
69397>>>                        Get Value of oUserIDForm to sUser
69398>>>                        Get Value of oPwdForm to sPwd
69399>>>                    End
69399>>>>
69399>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
69400>>>                End
69400>>>>
69400>>>            End
69400>>>>
69400>>>        End
69400>>>>
69400>>>        Function_Return bOk
69401>>>    End_Function
69402>>>    
69402>>>    
69402>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
69403>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
69404>>>End_Object
69405>>>
69405>    End_Object
69406>
69406>End_Object
69407>
69407>Object oToolTipController is a cToolTipController
69409>    Move Self to ghoToolTipController
69410>End_Object
69411>
69411>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 20.0\Pkg\oEditContextMenu.pkg)
69411>>>Use cCJStandardMenuItemClasses.pkg
69411>>>
69411>>>Object oEditContextMenu is a cCJContextMenu
69413>>>    
69413>>>    Move Self to Default_Form_Floating_Menu_ID
69414>>>    
69414>>>    Object oUndoMenuItem is a cCJUndoMenuItem
69416>>>    End_Object
69417>>>    
69417>>>    Object oCutMenuItem is a cCJCutMenuItem
69419>>>        Set pbControlBeginGroup to True
69420>>>    End_Object
69421>>>    
69421>>>    Object oCopyMenuItem is a cCJCopyMenuItem
69423>>>    End_Object
69424>>>
69424>>>    Object oPasteMenuItem is a cCJPasteMenuItem
69426>>>    End_Object
69427>>>
69427>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
69429>>>    End_Object
69430>>>
69430>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
69432>>>        Set pbControlBeginGroup to True
69433>>>    End_Object
69434>>>
69434>>>End_Object
69435>>>
69435>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 20.0\Pkg\oDEOEditContextMenu17.pkg)
69435>>>Use Windows.pkg
69435>>>Use cCJStandardMenuItemClasses.pkg
69435>>>Use cCJDeoMenuItemClasses.pkg
69435>>>
69435>>>
69435>>>Object oDEOEditContextMenu17 is a cCJContextMenu
69437>>>    
69437>>>    Move Self to Default_dbFloating_Menu_ID
69438>>>    
69438>>>    Object oUndoMenuItem is a cCJUndoMenuItem
69440>>>    End_Object
69441>>>    
69441>>>    Object oCutMenuItem is a cCJCutMenuItem
69443>>>        Set pbControlBeginGroup to True
69444>>>    End_Object
69445>>>    
69445>>>    Object oCopyMenuItem is a cCJCopyMenuItem
69447>>>    End_Object
69448>>>
69448>>>    Object oPasteMenuItem is a cCJPasteMenuItem
69450>>>    End_Object
69451>>>
69451>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
69453>>>    End_Object
69454>>>
69454>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
69456>>>        Set pbControlBeginGroup to True
69457>>>    End_Object
69458>>>
69458>>>    Object oPromptMenuItem is a cCJPromptMenuItem
69460>>>        Set pbControlBeginGroup to True
69461>>>    End_Object
69462>>>
69462>>>    Object oFindNextMenu is a cCJFindNextMenuItem
69464>>>        Set pbControlBeginGroup to True
69465>>>    End_Object
69466>>>
69466>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
69468>>>    End_Object
69469>>>
69469>>>    Object oClearMenuItem is a cCJClearMenuItem
69471>>>        Set pbControlBeginGroup to True
69472>>>    End_Object
69473>>>
69473>>>    Object oClearAllMenu is a cCJClearAllMenuItem
69475>>>    End_Object
69476>>>
69476>>>    Object oSaveMenu is a cCJSaveMenuItem
69478>>>    End_Object
69479>>>    
69479>>>    Object oDeleteMenu is a cCJDeleteMenuItem
69481>>>    End_Object
69482>>>
69482>>>    Object oRememberitem is a cCJRememberFieldMenuItem
69484>>>        Set pbControlBeginGroup to True
69485>>>    End_Object
69486>>>
69486>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
69488>>>    End_Object
69489>>>
69489>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
69491>>>    End_Object
69492>>>
69492>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
69494>>>    End_Object
69495>>>
69495>>>End_Object
69496>
69496>Object oMain is a Panel
69498>    Set Label to "Foto"
69499>    Set Location to 4 3
69500>    Set Size to 300 450
69501>    Set Icon to "Default.ico"
69502>
69502>    Object oCommandBarSystem is a cCJCommandBarSystem
69504>        Set pbTimerUpdate to True
69505>        Set peVisualTheme to xtpThemeOffice2013Outlook
69506>        Set pbAutoResizeIcons to True
69507>
69507>        Procedure OnCreateCommandBars
69510>            Handle hoOptions
69510>            Get OptionsObject to hoOptions
69511>            Forward Send OnCreateCommandBars
69513>        End_Procedure
69514>
69514>        Object oMenuBar is a cCJMenuBar
69516>
69516>            Object oFileMenu is a cCJMenuItem
69518>                Set peControlType to xtpControlPopup          
69519>                Set psCaption   to "&File"
69520>                Set psDescription to "Find, Save, Delete, Clear information or quit this application."
69521>                Set psCategory to "Menus"
69522>
69522>                Object oClearMenuItem is a cCJClearMenuItem
69524>                    Set pbAddToDesignerMenu to True
69525>                End_Object
69526>
69526>                Object oClearAllMenu is a cCJClearAllMenuItem
69528>                    Set pbAddToDesignerMenu to True
69529>                End_Object
69530>
69530>                Object oPromptMenuItem is a cCJPromptMenuItem
69532>                    Set pbAddToDesignerMenu to True
69533>                    Set pbControlBeginGroup to True
69534>                End_Object
69535>
69535>                Object oFindMenuItem is a cCJFindMenuItem
69537>                    Set pbAddToDesignerMenu to True
69538>                    Set pbControlBeginGroup to True
69539>                End_Object
69540>
69540>                Object oFindNextMenu is a cCJFindNextMenuItem
69542>                    Set pbAddToDesignerMenu to True
69543>                End_Object
69544>
69544>                Object oFindPreviousMenu is a cCJFindPreviousMenuItem
69546>                    Set pbAddToDesignerMenu to True
69547>                End_Object
69548>
69548>                Object oFindFirstMenu is a cCJFindFirstMenuItem
69550>                    Set pbAddToDesignerMenu to True
69551>                End_Object
69552>
69552>                Object oFindLastMenu is a cCJFindLastMenuItem
69554>                    Set pbAddToDesignerMenu to True
69555>                End_Object
69556>
69556>                Object oSaveMenuItem is a cCJSaveMenuItem
69558>                    Set pbAddToDesignerMenu to True
69559>                    Set pbControlBeginGroup to True
69560>                End_Object
69561>
69561>                Object oDeleteMenuItem is a cCJDeleteMenuItem
69563>                    Set pbAddToDesignerMenu to True
69564>                End_Object
69565>
69565>                Object oExitMenu is a cCJExitMenuItem
69567>                    Set pbControlBeginGroup to True
69568>                End_Object
69569>
69569>            End_Object
69570>
69570>            Object oViewMenu is a cCJMenuItem
69572>                Set peControlType to xtpControlPopup
69573>                Set psCaption to "&View"
69574>                Set psToolTip to "View"
69575>                Set psDescription to "Available Views"
69576>
69576>                Object oScanFotoMenuItem is a cCJMenuItem
69578>                    Set psCaption to "ScanFoto"
69579>                    Set psTooltip to "ScanFoto"
69580>                
69580>                    Procedure OnExecute Variant vCommandBarControl
69583>                        Handle hoClient
69583>                        Get Client_Id to hoClient
69584>                        Send Activate_oScanFoto of hoClient
69585>                    End_Procedure
69586>                End_Object
69587>
69587>                Object oHernummerenFotoMenuItem is a cCJMenuItem
69589>                    Set psCaption to "HernummerenFoto"
69590>                    Set psTooltip to "HernummerenFoto"
69591>                
69591>                    Procedure OnExecute Variant vCommandBarControl
69594>                        Handle hoClient
69594>                        Get Client_Id to hoClient
69595>                        Send Activate_oHernummerenFoto of hoClient
69596>                    End_Procedure
69597>                End_Object
69598>            End_Object
69599>            
69599>            Object oReportMenu is a cCJMenuItem
69601>                Set peControlType to xtpControlPopup          
69602>                Set psCaption to "&Report"
69603>                Set psToolTip to "Report"
69604>                Set psDescription to "Available Reports"
69605>            End_Object
69606>
69606>            Object oNavigateMenu is a cCJMenuItem
69608>                Set peControlType to xtpControlPopup      
69609>                Set psCaption to "&Navigate"    
69610>                Set psTooltip to "Navigate"    
69611>                Set psDescription to "Move to different areas of the application"
69612>
69612>                Object oNextAreaMenu is a cCJNextAreaMenu
69614>                End_Object
69615>
69615>                Object oPriorAreaMenu is a cCJPriorAreaMenu
69617>                End_Object
69618>
69618>                Object oNextViewMenu is a cCJNextViewMenu
69620>                End_Object
69621>
69621>                Object oPriorViewMenu is a cCJPriorViewMenu
69623>                End_Object
69624>
69624>                Object oPromptMenu is a cCJPromptMenuItem
69626>                    Set pbControlBeginGroup to True
69627>                End_Object
69628>
69628>                Object oZoomMenu is a cCJZoomMenuItem
69630>                End_Object
69631>
69631>            End_Object
69632>
69632>            Object oWindowMenu is a cCJMDIWindowsMenuItem
69634>                Set peControlType to xtpControlPopup
69635>                Set psCaption to "&Window"
69636>                Set psToolTip to "Window"
69637>                Set psDescription to "Display Current Views and set other display options."    
69638>
69638>                // These are the static windows items. More will be created in onInitPopup 
69638>                Object oDisplayOptionsMenu is a cCJMenuItem
69640>                    Set peControlType to xtpControlPopup          
69641>                    Set psCaption to "&Display Options"
69642>                    Set psToolTip to "Display Options"
69643>                    Set psDescription to "Set display options"
69644>
69644>                    Object oStatusbarMenu is a cCJStatusbarMenuItem
69646>                    End_Object
69647>
69647>                    Object oAutoArrangeIconsMenu is a cCJAutoArrangeIconsMenuItem
69649>                    End_Object
69650>
69650>                    Object oRestoreMenusMenu is a cCJRestoreMenusMenuItem
69652>                        Set pbControlBeginGroup to True
69653>                    End_Object
69654>
69654>                End_Object
69655>
69655>                Object oCascadeMenu is a cCJCascadeMenuItem
69657>                    Set pbControlBeginGroup to True
69658>                End_Object
69659>
69659>                Object oHorizTile is a cCJTileHorizontally
69661>                End_Object
69662>
69662>                Object oVertTile is a cCJTileVertically
69664>                End_Object
69665>
69665>                Object oMinimizeMenuItem is a cCJMinimizeWindowsMenuItem
69667>                    Set pbControlBeginGroup to True
69668>                End_Object
69669>
69669>                Object oRestoreMenuItem is a cCJRestoreWindowsMenuItem
69671>                End_Object
69672>
69672>                Object oArrangeIconsMenuItem is a cCJAutoArrangeIconsMenuItem
69674>                    Set pbControlBeginGroup to True
69675>                End_Object
69676>
69676>            End_Object
69677>
69677>            Object oHelpMenu is a cCJMenuItem
69679>                Set peControlType to xtpControlPopup    
69680>                Set psCaption to "&Help"
69681>                Set psDescription to "Access Information for learning and using this DataFlex application."
69682>                Set psToolTip to "Help"
69683>
69683>                Object oHelpMenuItem is a cCJHelpMenuItem 
69685>                End_Object
69686>
69686>                Object oAboutMenuItem is a cCJAboutMenuItem
69688>                End_Object
69689>
69689>            End_Object
69690>
69690>        End_Object
69691>
69691>        Object oFindToolBar is a cCJToolbar
69693>            Set psTitle to "Finding Toolbar"
69694>
69694>            Object oFindFirstTool is a cCJFindFirstMenuItem
69696>            End_Object
69697>
69697>            Object oFindPreviousTool is a cCJFindPreviousMenuItem
69699>            End_Object
69700>
69700>            Object oFindMenuTool is a cCJFindMenuItem
69702>            End_Object
69703>
69703>            Object oFindNextTool is a cCJFindNextMenuItem
69705>            End_Object
69706>
69706>            Object oFindLastTool is a cCJFindLastMenuItem
69708>            End_Object
69709>
69709>            Object oPromptToolItem is a cCJPromptMenuItem
69711>                Set pbControlBeginGroup to True
69712>            End_Object
69713>
69713>        End_Object
69714>
69714>        Object oFileToolBar is a cCJToolbar
69716>            Set psTitle to "Data Entry Toolbar"
69717>
69717>            Object oClearToolItem is a cCJClearMenuItem
69719>                Set peControlStyle to xtpButtonIconAndCaption
69720>            End_Object
69721>
69721>            Object oClearAllToolItem2 is a cCJClearAllMenuItem
69723>                Set peControlStyle to xtpButtonIconAndCaption
69724>            End_Object
69725>
69725>            Object oSaveToolItem is a cCJSaveMenuItem
69727>                Set peControlStyle to xtpButtonIconAndCaption
69728>                Set pbControlBeginGroup to True
69729>            End_Object
69730>
69730>            Object oDeleteToolItem is a cCJDeleteMenuItem
69732>                Set peControlStyle to xtpButtonIconAndCaption
69733>            End_Object
69734>
69734>        End_Object
69735>
69735>        Object oEditToolBar is a cCJToolbar
69737>            Set psTitle to "Edit Toolbar"
69738>
69738>            Object oCutToolbarItem is a cCJCutMenuItem
69740>            End_Object
69741>
69741>            Object oCopyToolbarItem is a cCJCopyMenuItem
69743>            End_Object
69744>
69744>            Object oPasteToolbarItem is a cCJPasteMenuItem
69746>            End_Object
69747>
69747>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
69749>                Set pbControlBeginGroup to True
69750>            End_Object
69751>
69751>        End_Object
69752>
69752>        Object oRememberToolbar is a cCJToolbar
69754>            Set psTitle to C_$Remember
69755>
69755>            Object oRememberItems is a cCJMenuItem
69757>
69757>                Set peControlType to xtpControlPopup
69758>                Set peControlStyle to xtpButtonCaption
69759>                Set psCaption to C_$Remember
69760>                
69760>                Object oMenuItem is a cCJRememberFieldMenuItem
69762>                    Set peControlStyle to xtpButtonIconAndCaption
69763>                End_Object
69764>                
69764>                Object oMenuItem is a cCJRememberLastFieldMenuItem
69766>                    Set peControlStyle to xtpButtonIconAndCaption
69767>                End_Object
69768>                
69768>                Object oMenuItem is a cCJUnRememberFieldMenuItem
69770>                    Set peControlStyle to xtpButtonIconAndCaption
69771>                End_Object
69772>                
69772>                Object oMenuItem is a cCJUnRememberFieldAllMenuItem
69774>                    Set peControlStyle to xtpButtonIconAndCaption
69775>                End_Object
69776>
69776>            End_Object
69777>            
69777>        End_Object
69778>        
69778>        Object oStatusBar is a cCJStatusBar
69780>
69780>            Object oStatusPane1 is a cCJStatusBarPane
69782>                Set piID to sbpIDIdlePane
69783>                Set pbStyleStretch to True
69784>            End_Object
69785>
69785>            Object oStatusPane2 is a cCJStatusBarPane
69787>                Set phoViewPane to Self
69788>                Set pbStyleStretch to True
69789>            End_Object
69790>
69790>        End_Object
69791>
69791>    End_Object
69792>
69792>    Object oClientArea is a ClientArea
69794>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Program Files\DataFlex 20.0\Pkg\StdAbout.pkg)
69794>>>// This provides a quick and simple way to create an about package for a program.
69794>>>// You need to create a message inside you client area called Activate_About.
69794>>>// Within this message you should send the message DoAbout passing needed
69794>>>// string information.
69794>>>//
69794>>>//       Procedure Activate_About
69794>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
69794>>>//       End_Procedure
69794>>>//    where: sTitle =     Name of application. If none provided, uses caption
69794>>>//                        bar title
69794>>>//           sVersion   = Version Line. If none provided, will be blank
69794>>>//           sCopyRight = Copyright Line. If none provided, will be blank
69794>>>//           sAuthor    = Author name, blank if none provided
69794>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
69794>>>//                        is used.
69794>>>// It is expected that you will place this in your own object package. For
69794>>>// example an order about package may look like this:
69794>>>//
69794>>>//   // OrderAbout.pkg
69794>>>//   Use StdAbout.pkg
69794>>>//   Procedure Activate_About
69794>>>//      String sTitle sCopyright sVersion sAuthor
69794>>>//      Move "My Order Entry System" to sTitle
69794>>>//      Move "Version 2.1" to sVersion
69794>>>//      Move "Copyright xxxx, Super Software Inc." to sCopyright
69794>>>//      Move "John Smith"  to sAuthor
69794>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
69794>>>//   end_procedure
69794>>>//   // end of file.
69794>>>
69794>>>Use DfAbout.pkg
Including file: Dfabout.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Dfabout.pkg)
69794>>>>>Use LanguageText.pkg
69794>>>>>Use Windows.pkg
69794>>>>>Use DFbitmap.pkg
69794>>>>>Use GlobalFunctionsProcedures.pkg
69794>>>>>Use cTextEdit.pkg
69794>>>>>Use tWinStructs.pkg
69794>>>>>
69794>>>>>Use cli.pkg
69794>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 20.0\Pkg\DFBTRDRV.PKG)
69794>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
69794>>>>>>>// Notice      : This package contains constants and commands, used to call
69794>>>>>>>//               specific functions in the DFBTRDRV.
69794>>>>>>>Use Ui
69794>>>>>>>//
69794>>>>>>>// Driver Indentification
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>// Driver attributes
69794>>>>>>>//
69794>>>>>>>// Call_Driver functions ID's
69794>>>>>>>//
69794>>>>>>>//
69794>>>>>>>// DFBTRFN_CONVERT_FILE options
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// DFBTRFN_SET_OWNER options
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// Command to create all vars which may be needed
69794>>>>>>>// in other commands.
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// Command to set the owner of a Btrieve file.
69794>>>>>>>// File must have been opened.
69794>>>>>>>// Filenumber needs to be passed.
69794>>>>>>>// To clear set the owner to "".
69794>>>>>>>// Examples:
69794>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
69794>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
69794>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
69794>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
69794>>>>>>>// To clear:
69794>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// Command to parse DFBTR_SET_OWNVER
69794>>>>>>>// options.
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// Command to parse for Callback
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// Command to clear the owner of a Btrieve file.
69794>>>>>>>// File must have been opened.
69794>>>>>>>// Filenumber needs to be passed.
69794>>>>>>>// Examples:
69794>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// Command to add a owner name to the internal list of ownernames
69794>>>>>>>// which will be tries when opening files.
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// Command to remove all owners from the internal list of ownernames
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// Command to set the owner name to be used when opening the DDF files.
69794>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
69794>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
69794>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// Command to change the transaction type.
69794>>>>>>>// Valid types are:
69794>>>>>>>//     DFBTRTT_NONE
69794>>>>>>>//     DFBTRTT_EXCLUSIVE
69794>>>>>>>//     DFBTRTT_CONCURRENT
69794>>>>>>>//
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// Command to get the current transaction type.
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// Command to set explicit_locking
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// Command to get explicit locking
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>//
69794>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
69794>>>>>>>//
69794>>>>>>>
69794>>>>>>>// Purpose: An instance of this class can be used as a broker object to
69794>>>>>>>//          call several Dfbtrdrv releated methods.
69794>>>>>>>
69794>>>>>>>Class cDFBtrDrvHandler is an Array
69795>>>>>>>    
69795>>>>>>>    Procedure Construct_Object Integer iImage
69797>>>>>>>        Forward Send Construct_object iImage
69799>>>>>>>        
69799>>>>>>>        Property String  psDriverID "DFBTRDRV"
69800>>>>>>>    End_Procedure
69801>>>>>>>    
69801>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
69801>>>>>>>    //
69801>>>>>>>    
69801>>>>>>>    Function CKRevision Returns String
69803>>>>>>>        String  sDriverID
69803>>>>>>>        String  sRevision
69803>>>>>>>        String  sVoid
69803>>>>>>>        Integer iRetval
69803>>>>>>>        
69803>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69803>>>>>>>        // This error would otherwise be raised when we have an older
69803>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69803>>>>>>>        Send Ignore_error to Error_object_Id 20491
69804>>>>>>>        Get psDriverID to sDriverID
69805>>>>>>>        Move (Repeat(" ", 255)) to sRevision
69806>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
69811>>>>>>>        Send Trap_Error to Error_object_Id 20491
69812>>>>>>>        If (Trim(sRevision) = "") Begin
69814>>>>>>>            // Unable to get the revision. return all zeroes.
69814>>>>>>>            Move "0.0.0.0" to sRevision
69815>>>>>>>        End
69815>>>>>>>>
69815>>>>>>>        Function_Return sRevision
69816>>>>>>>    End_Function
69817>>>>>>>    
69817>>>>>>>    Function CkUsesUri Returns Integer
69819>>>>>>>        String  sDriverID
69819>>>>>>>        String  sVoid1
69819>>>>>>>        String  sVoid2
69819>>>>>>>        Integer iRetval
69819>>>>>>>        
69819>>>>>>>        Get psDriverID to sDriverID
69820>>>>>>>        
69820>>>>>>>        Move 0 to iRetval
69821>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69821>>>>>>>        // This error would otherwise be raised when we have an older
69821>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
69821>>>>>>>        Send Ignore_error to Error_object_Id 20491
69822>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
69827>>>>>>>        Send Trap_Error to Error_object_Id 20491
69828>>>>>>>        
69828>>>>>>>        Function_Return iRetval
69829>>>>>>>    End_Function
69830>>>>>>>    
69830>>>>>>>    
69830>>>>>>>    
69830>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
69830>>>>>>>    //
69830>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
69830>>>>>>>    //
69830>>>>>>>    
69830>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
69832>>>>>>>        Integer iPartRev
69832>>>>>>>        Integer iCurrentPart
69832>>>>>>>        Integer iSeparatorPos
69832>>>>>>>        
69832>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
69835>>>>>>>        
69835>>>>>>>        Move 0 to iCurrentPart
69836>>>>>>>        Repeat
69836>>>>>>>>
69836>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
69837>>>>>>>            If (iSeparatorPos > 0) Begin
69839>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
69840>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
69841>>>>>>>                Increment iCurrentPart
69842>>>>>>>            End
69842>>>>>>>>
69842>>>>>>>            Else If (sRevision <> "") Begin
69845>>>>>>>                Move sRevision to iPartRev
69846>>>>>>>                Move "" to sRevision
69847>>>>>>>                Increment iCurrentPart
69848>>>>>>>            End
69848>>>>>>>>
69848>>>>>>>            Else ;                Move -1 to iPartRev
69850>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
69852>>>>>>>        
69852>>>>>>>        Function_Return iPartRev
69853>>>>>>>    End_Function
69854>>>>>>>    
69854>>>>>>>    
69854>>>>>>>    
69854>>>>>>>    //
69854>>>>>>>    //  Returns the major revision of the CK
69854>>>>>>>    //
69854>>>>>>>    
69854>>>>>>>    Function CKMajorRevision Returns Integer
69856>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
69857>>>>>>>    End_Function
69858>>>>>>>    
69858>>>>>>>    
69858>>>>>>>    
69858>>>>>>>    //  Returns the minor revision of the CK
69858>>>>>>>    //
69858>>>>>>>    
69858>>>>>>>    Function CKMinorRevision Returns Integer
69860>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
69861>>>>>>>    End_Function
69862>>>>>>>    
69862>>>>>>>    
69862>>>>>>>    //  Returns the release revision of the CK
69862>>>>>>>    //
69862>>>>>>>    
69862>>>>>>>    Function CKReleaseRevision Returns Integer
69864>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
69865>>>>>>>    End_Function
69866>>>>>>>    
69866>>>>>>>    
69866>>>>>>>    //  Returns the major revision of the CK
69866>>>>>>>    //
69866>>>>>>>    
69866>>>>>>>    Function CKBuildRevision Returns Integer
69868>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
69869>>>>>>>    End_Function
69870>>>>>>>    
69870>>>>>>>    
69870>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
69870>>>>>>>    //
69870>>>>>>>    
69870>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
69872>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
69875>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
69878>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
69881>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
69884>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
69887>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
69891>>>>>>>            End
69891>>>>>>>>
69891>>>>>>>        End
69891>>>>>>>>
69891>>>>>>>        
69891>>>>>>>        Function_Return (False)
69892>>>>>>>    End_Function
69893>>>>>>>    
69893>>>>>>>    //   Functions to query the Pervasive.SQL version:
69893>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
69893>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
69893>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
69893>>>>>>>    //
69893>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
69893>>>>>>>    //   in the following format:
69893>>>>>>>    //       <version>.<revision>.<type>
69893>>>>>>>    //   possible values for <type>:
69893>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
69893>>>>>>>    //         server using Workgroup authentication mode
69893>>>>>>>    //       C for client cache engine
69893>>>>>>>    //       D for DOS workstation
69893>>>>>>>    //       N for client Requester
69893>>>>>>>    //       S for NetWare server
69893>>>>>>>    //       T for 32-bit Windows server engine
69893>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
69893>>>>>>>    //
69893>>>>>>>    //   example:
69893>>>>>>>    //       8.50.T
69893>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
69893>>>>>>>    //   32-bits Windows server.
69893>>>>>>>    //
69893>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
69893>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
69893>>>>>>>    //
69893>>>>>>>    //   If the version information is not available or can not be obtained
69893>>>>>>>    //   the functions will return "0.0.0"
69893>>>>>>>    
69893>>>>>>>    //  Returns the version information of the
69893>>>>>>>    //           Pervasive.SQL Client requester.
69893>>>>>>>    
69893>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
69895>>>>>>>        
69895>>>>>>>        String  sDriverID
69895>>>>>>>        String  sVersion
69895>>>>>>>        String  sVoid
69895>>>>>>>        Integer iRetval
69895>>>>>>>        
69895>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69895>>>>>>>        // This error would otherwise be raised when we have an older
69895>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69895>>>>>>>        Send Ignore_error to Error_object_Id 20491
69896>>>>>>>        Get psDriverID to sDriverID
69897>>>>>>>        Move (Repeat(" ", 255)) to sVersion
69898>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
69903>>>>>>>        Send Trap_Error to Error_object_Id 20491
69904>>>>>>>        If (Trim(sVersion) = "") Begin
69906>>>>>>>            // Unable to get the revision. return all zeroes.
69906>>>>>>>            Move "0.0.0" to sVersion
69907>>>>>>>        End
69907>>>>>>>>
69907>>>>>>>        Function_Return sVersion
69908>>>>>>>    End_Function
69909>>>>>>>    
69909>>>>>>>    //           Pervasive.SQL Engine
69909>>>>>>>    
69909>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
69911>>>>>>>        
69911>>>>>>>        String  sDriverID
69911>>>>>>>        String  sVersion
69911>>>>>>>        String  sVoid
69911>>>>>>>        Integer iRetval
69911>>>>>>>        
69911>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69911>>>>>>>        // This error would otherwise be raised when we have an older
69911>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69911>>>>>>>        Send Ignore_error to Error_object_Id 20491
69912>>>>>>>        Get psDriverID to sDriverID
69913>>>>>>>        Move (Repeat(" ", 255)) to sVersion
69914>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
69919>>>>>>>        Send Trap_Error to Error_object_Id 20491
69920>>>>>>>        If (Trim(sVersion) = "") Begin
69922>>>>>>>            // Unable to get the revision. return all zeroes.
69922>>>>>>>            Move "0.0.0" to sVersion
69923>>>>>>>        End
69923>>>>>>>>
69923>>>>>>>        Function_Return sVersion
69924>>>>>>>    End_Function
69925>>>>>>>    
69925>>>>>>>    //  Returns the version information of the
69925>>>>>>>    //           Pervasive.SQL Server Engine
69925>>>>>>>    
69925>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
69927>>>>>>>        
69927>>>>>>>        String  sDriverID
69927>>>>>>>        String  sVersion
69927>>>>>>>        String  sVoid
69927>>>>>>>        Integer iRetval
69927>>>>>>>        
69927>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69927>>>>>>>        // This error would otherwise be raised when we have an older
69927>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69927>>>>>>>        Send Ignore_error to Error_object_Id 20491
69928>>>>>>>        Get psDriverID to sDriverID
69929>>>>>>>        Move (Repeat(" ", 255)) to sVersion
69930>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
69935>>>>>>>        Send Trap_Error to Error_object_Id 20491
69936>>>>>>>        If (Trim(sVersion) = "") Begin
69938>>>>>>>            // Unable to get the revision. return all zeroes.
69938>>>>>>>            Move "0.0.0" to sVersion
69939>>>>>>>        End
69939>>>>>>>>
69939>>>>>>>        Function_Return sVersion
69940>>>>>>>    End_Function
69941>>>>>>>    
69941>>>>>>>End_Class
69942>>>>>>>
69942>>>>>>>
69942>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files\DataFlex 20.0\Pkg\MSSqldrv.pkg)
69942>>>>>>>//     Package that declares MS SQL driver constants and functions.
69942>>>>>>>//     This package can be used by developers who want to add Data Access
69942>>>>>>>//     MS SQL Client specific code to a DataFlex application.
69942>>>>>>>
69942>>>>>>>Use Cli.pkg
69942>>>>>>>Use SQL.pkg
69942>>>>>>>
69942>>>>>>>//   Driver Indentification
69942>>>>>>>
69942>>>>>>>//   Error number constants
69942>>>>>>>
69942>>>>>>>
69942>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
69942>>>>>>>
69942>>>>>>>
69942>>>>>>>
69942>>>>>>>
69942>>>>>>>
69942>>>>>>>
69942>>>>>>>// SQL Server spcific types.
69942>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
69942>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
69942>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
69942>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
69942>>>>>>>
69942>>>>>>>// SQL Server spcific types.
69942>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
69942>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
69942>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
69942>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
69942>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
69942>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
69942>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
69942>>>>>>>
69942>>>>>>>
69942>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
69942>>>>>>>//
69942>>>>>>>//     Setup a constraint for a file.
69942>>>>>>>
69942>>>>>>>
69942>>>>>>>Class cMSSQLHandler is a cCLIHandler
69943>>>>>>>    
69943>>>>>>>    Procedure Construct_Object
69945>>>>>>>        Forward Send Construct_Object
69947>>>>>>>        
69947>>>>>>>        Set psDriverID to MSSQLDRV_ID
69948>>>>>>>    End_Procedure
69949>>>>>>>    
69949>>>>>>>    
69949>>>>>>>    
69949>>>>>>>    //   Extract the list from the out connect string.
69949>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
69951>>>>>>>        String  sItem
69951>>>>>>>        Integer iStart
69951>>>>>>>        Integer iEnd
69951>>>>>>>        
69951>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
69954>>>>>>>        
69954>>>>>>>        Send Delete_Data to hoStore
69955>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
69956>>>>>>>        While (iStart > 0)
69960>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
69961>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
69964>>>>>>>            Else Begin
69965>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
69966>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
69967>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
69970>>>>>>>                
69970>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
69973>>>>>>>                
69973>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
69976>>>>>>>            End
69976>>>>>>>>
69976>>>>>>>        Loop
69977>>>>>>>>
69977>>>>>>>        
69977>>>>>>>        Function_Return (Item_Count(hoStore))
69978>>>>>>>    End_Procedure
69979>>>>>>>    
69979>>>>>>>    
69979>>>>>>>    
69979>>>>>>>    //   Call the driver's browse connect function
69979>>>>>>>    Function BrowseConnect String sInConnStr Returns String
69981>>>>>>>        String  sDriver
69981>>>>>>>        String  sOutConnStr
69981>>>>>>>        Integer iArg
69981>>>>>>>        Integer iRetval
69981>>>>>>>        
69981>>>>>>>        Get psDriverID to sDriver
69982>>>>>>>        If (sDriver <> "") Begin
69984>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
69985>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
69990>>>>>>>        End
69990>>>>>>>>
69990>>>>>>>        
69990>>>>>>>        Function_Return sOutConnStr
69991>>>>>>>    End_Function// BrowseConnect
69992>>>>>>>    
69992>>>>>>>    
69992>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
69994>>>>>>>        String  sDriver
69994>>>>>>>        String  sOutConnStr
69994>>>>>>>        Integer iArg
69994>>>>>>>        Integer iRetval
69994>>>>>>>        
69994>>>>>>>        Move 1 to iArg // Browses only local
69995>>>>>>>        
69995>>>>>>>        Get psDriverID to sDriver
69996>>>>>>>        If (sDriver <> "") Begin
69998>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
69999>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
70004>>>>>>>        End
70004>>>>>>>>
70004>>>>>>>        
70004>>>>>>>        Function_Return sOutConnStr
70005>>>>>>>    End_Function// BrowseConnect
70006>>>>>>>    
70006>>>>>>>    
70006>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
70008>>>>>>>        
70008>>>>>>>        String  sServerList
70008>>>>>>>        Integer iNumServers
70008>>>>>>>        Integer iDriver
70008>>>>>>>        Integer iClientVersion
70008>>>>>>>        String  sDriver
70008>>>>>>>        
70008>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
70009>>>>>>>        
70009>>>>>>>        If (iDriver) Begin
70011>>>>>>>            
70011>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
70014>>>>>>>            
70014>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
70015>>>>>>>            
70015>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
70016>>>>>>>            If (iNetworkLocal = 0) Begin
70018>>>>>>>                Get BrowseConnect sDriver to sServerList
70019>>>>>>>            End
70019>>>>>>>>
70019>>>>>>>            Else Begin
70020>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
70021>>>>>>>            End
70021>>>>>>>>
70021>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
70022>>>>>>>        End
70022>>>>>>>>
70022>>>>>>>        
70022>>>>>>>        Function_Return iNumServers
70023>>>>>>>        
70023>>>>>>>    End_Function
70024>>>>>>>    
70024>>>>>>>    //   Enumerate the available SQL Server database servers
70024>>>>>>>    //   This function will return all SQL Server instances on the network.
70024>>>>>>>    //   This may take a long time.
70024>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
70024>>>>>>>    Function EnumerateServers Returns Integer
70026>>>>>>>        
70026>>>>>>>        Integer iNumServers
70026>>>>>>>        Integer iNetworkLocal
70026>>>>>>>        
70026>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
70027>>>>>>>        
70027>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
70028>>>>>>>        
70028>>>>>>>        Function_Return iNumServers
70029>>>>>>>        
70029>>>>>>>    End_Function
70030>>>>>>>    
70030>>>>>>>    
70030>>>>>>>    //   Enumerate the available SQL Server database servers
70030>>>>>>>    //   This function will return only return SQL Server instance on the local machine
70030>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
70030>>>>>>>    Function EnumerateServersLocal Returns Integer
70032>>>>>>>        
70032>>>>>>>        Integer iNumServers
70032>>>>>>>        Integer iNetworkLocal
70032>>>>>>>        
70032>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
70033>>>>>>>        
70033>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
70034>>>>>>>        
70034>>>>>>>        Function_Return iNumServers
70035>>>>>>>        
70035>>>>>>>    End_Function
70036>>>>>>>    
70036>>>>>>>    
70036>>>>>>>    
70036>>>>>>>    //   Enumerate database in a given server.
70036>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
70038>>>>>>>        Integer hoSQL
70038>>>>>>>        String  sConnect
70038>>>>>>>        String  sDatabase
70038>>>>>>>        Integer hdbc
70038>>>>>>>        Integer hstmt
70038>>>>>>>        Integer iFetchResult
70038>>>>>>>        
70038>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
70041>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
70044>>>>>>>        
70044>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
70047>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
70049>>>>>>>        
70049>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
70051>>>>>>>            Move Current_Object to hoSQL
70052>>>>>>>        End_Object
70053>>>>>>>        
70053>>>>>>>        If (hoSQL <> 0) Begin
70055>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
70056>>>>>>>            If (hdbc <> 0) Begin
70058>>>>>>>                Get SQLOpen of hdbc to hstmt
70059>>>>>>>                If (hstmt <> 0) Begin
70061>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
70061>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
70061>>>>>>>                    //   approach in case meta data might change, the stored procedure will
70061>>>>>>>                    //   stay the same.
70061>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
70062>>>>>>>                    Send SQLCall to hstmt
70063>>>>>>>                    Repeat
70063>>>>>>>>
70063>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
70064>>>>>>>                        If (iFetchResult <> 0) Begin
70066>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
70067>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
70068>>>>>>>                        End
70068>>>>>>>>
70068>>>>>>>                    Until (iFetchResult = 0)
70070>>>>>>>                    
70070>>>>>>>                    Send SQLClose to hstmt
70071>>>>>>>                End
70071>>>>>>>>
70071>>>>>>>                Send SQLDisconnect to hdbc
70072>>>>>>>            End
70072>>>>>>>>
70072>>>>>>>        End
70072>>>>>>>>
70072>>>>>>>        Send Destroy_Object to hoSQL
70073>>>>>>>        
70073>>>>>>>        Function_Return (Item_Count(Current_Object))
70074>>>>>>>    End_Function
70075>>>>>>>    
70075>>>>>>>    
70075>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
70077>>>>>>>        
70077>>>>>>>        String  sSqlServerClientVersionName
70077>>>>>>>        
70077>>>>>>>        
70077>>>>>>>        Case Begin
70077>>>>>>>            
70077>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
70079>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
70080>>>>>>>                Case Break
70081>>>>>>>                
70081>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
70084>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
70085>>>>>>>                Case Break
70086>>>>>>>            
70086>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
70089>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
70090>>>>>>>                Case Break
70091>>>>>>>            
70091>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
70094>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
70095>>>>>>>                Case Break
70096>>>>>>>            
70096>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
70099>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
70100>>>>>>>                Case Break
70101>>>>>>>            
70101>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
70104>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
70105>>>>>>>                Case Break
70106>>>>>>>            
70106>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
70109>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
70110>>>>>>>                Case Break
70111>>>>>>>            
70111>>>>>>>            Case Else
70111>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
70112>>>>>>>                
70112>>>>>>>        Case End
70112>>>>>>>        
70112>>>>>>>        
70112>>>>>>>        Function_Return sSqlServerClientVersionName
70113>>>>>>>        
70113>>>>>>>    End_Function
70114>>>>>>>
70114>>>>>>>
70114>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
70116>>>>>>>        
70116>>>>>>>        String  sSqlServerClientDriverName
70116>>>>>>>        
70116>>>>>>>        Case Begin
70116>>>>>>>            
70116>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
70118>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
70119>>>>>>>                Case Break
70120>>>>>>>                
70120>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
70123>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
70124>>>>>>>                Case Break
70125>>>>>>>            
70125>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
70128>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
70129>>>>>>>                Case Break
70130>>>>>>>            
70130>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
70133>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
70134>>>>>>>                Case Break
70135>>>>>>>            
70135>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
70138>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
70139>>>>>>>                Case Break
70140>>>>>>>            
70140>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
70143>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
70144>>>>>>>                Case Break
70145>>>>>>>            
70145>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
70148>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
70149>>>>>>>                Case Break
70150>>>>>>>            
70150>>>>>>>            Case Else
70150>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
70151>>>>>>>                
70151>>>>>>>        Case End
70151>>>>>>>        
70151>>>>>>>        
70151>>>>>>>        Function_Return sSqlServerClientDriverName
70152>>>>>>>        
70152>>>>>>>    End_Function
70153>>>>>>>    
70153>>>>>>>    
70153>>>>>>>End_Class
70154>>>>>>>
70154>>>>>>>
70154>>>>>
70154>>>>>Register_Function phoWorkspace Returns Handle
70154>>>>>Register_Function Help_filename Returns String
70154>>>>>Register_Function GetHelpFile Returns String
70154>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
70154>>>>>
70154>>>>>// Do not call directly, use the wrapper function instead
70154>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
70155>>>>>
70155>>>>>// Wrapper Function WNetGetUser
70155>>>>>Function WNetGetUser Global ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
70157>>>>>    
70157>>>>>    DWord   dwResult     
70157>>>>>    UWide   uwName uwUserName
70157>>>>>    UWide   uwName uwUserName
70157>>>>>        
70157>>>>>    Send StringToWide lpName (&uwName)
70158>>>>>    
70158>>>>>    Send WideSetBuffer lpUser_Name lpLength (&uwUserName)    
70159>>>>>    
70159>>>>>    Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
70160>>>>>    
70160>>>>>    Send WideToString (&uwUserName) lpUser_Name
70161>>>>>    
70161>>>>>    Function_Return dwResult
70162>>>>>End_Function
70163>>>>>
70163>>>>>//    This function reads the current username Of windows and returns that
70163>>>>>//    name or an text unknown user
70163>>>>>Function Network_User_Name for cDesktop Returns String
70165>>>>>    WString wName
70165>>>>>    Integer iRetval iLength
70165>>>>>    
70165>>>>>    Move 0 to iLength
70166>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
70167>>>>>    Move (ZeroString(iLength)) to wName
70168>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
70169>>>>>    
70169>>>>>    If (iRetval = NO_ERROR) Begin
70171>>>>>        Function_Return (CString (wName))
70172>>>>>    End
70172>>>>>>
70172>>>>>    
70172>>>>>    Function_Return "User Unknown"
70173>>>>>End_Function
70174>>>>>
70174>>>>>External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
70175>>>>>
70175>>>>>External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
70176>>>>>
70176>>>>>Class SysinfoDisplay is a cTextEdit
70177>>>>>    Procedure Construct_Object
70179>>>>>        Forward Send Construct_Object
70181>>>>>        
70181>>>>>        Set Location to 6 6
70182>>>>>        Set Size to 110 255
70183>>>>>        Set Read_Only_State to True
70184>>>>>        Set pbWrap to False
70185>>>>>    End_Procedure
70186>>>>>    
70186>>>>>    //    This method will show the name Of the current directory in the system
70186>>>>>    //    information box
70186>>>>>    Procedure Show_Current_Directory
70188>>>>>        String sDir
70188>>>>>        
70188>>>>>        Get_Current_Directory to sDir
70189>>>>>        
70189>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
70190>>>>>    End_Procedure
70191>>>>>    
70191>>>>>    Procedure Show_Windows_Directory
70193>>>>>        String sWindir
70193>>>>>        
70193>>>>>        Get_Windows_Directory to sWindir
70194>>>>>        
70194>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
70195>>>>>    End_Procedure
70196>>>>>    
70196>>>>>    Procedure Show_Current_User
70198>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
70199>>>>>    End_Procedure
70200>>>>>    
70200>>>>>    Procedure Show_Number_Format
70202>>>>>        Integer iFormat
70202>>>>>        String sFormatText
70202>>>>>        
70202>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
70205>>>>>        Move (Character (iFormat)) to sFormatText
70206>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
70207>>>>>        
70207>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
70210>>>>>        Move (Character (iFormat)) to sFormatText
70211>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
70212>>>>>    End_Procedure
70213>>>>>    
70213>>>>>    Procedure Show_Filelist_Name
70215>>>>>        String sFilename
70215>>>>>        
70215>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
70218>>>>>        
70218>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
70219>>>>>        Send AppendTextLn ""
70220>>>>>    End_Procedure
70221>>>>>    
70221>>>>>    Procedure Show_Lock_Delay
70223>>>>>        Integer iLockdelay
70223>>>>>        
70223>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
70226>>>>>        
70226>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
70227>>>>>    End_Procedure
70228>>>>>    
70228>>>>>    Procedure Show_Lock_Timeout
70230>>>>>        Integer iLockTimeout
70230>>>>>        
70230>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
70233>>>>>        
70233>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
70234>>>>>    End_Procedure
70235>>>>>    
70235>>>>>    Procedure Show_Screen_Size
70237>>>>>        Integer iYscreensize iXscreensize
70237>>>>>        
70237>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) to iXscreensize
70238>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) to iYscreensize
70239>>>>>        
70239>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
70240>>>>>    End_Procedure
70241>>>>>    
70241>>>>>    Procedure Show_Page_Size
70243>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
70244>>>>>    End_Procedure
70245>>>>>    
70245>>>>>    Procedure Show_Date
70247>>>>>        Date dToday
70247>>>>>        
70247>>>>>        Move (CurrentDateTime()) to  dToday
70248>>>>>        
70248>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
70249>>>>>    End_Procedure
70250>>>>>    
70250>>>>>    Procedure Show_Date_Format
70252>>>>>        Integer iDateFormat
70252>>>>>        String sDateFormat
70252>>>>>        
70252>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
70255>>>>>        Case Begin
70255>>>>>            Case (iDateFormat = DF_DATE_USA)
70257>>>>>                Move C_$USA to sDateFormat
70258>>>>>                Case Break
70259>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
70262>>>>>                Move C_$European to sDateFormat
70263>>>>>                Case Break
70264>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
70267>>>>>                Move C_$Military to sDateFormat
70268>>>>>                Case Break
70269>>>>>            Case Else
70269>>>>>                Move C_$UnknownDateType to sDateFormat
70270>>>>>                Case Break
70271>>>>>        Case End
70271>>>>>        
70271>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
70272>>>>>    End_Procedure
70273>>>>>    
70273>>>>>    Procedure Show_Systemresources
70275>>>>>        tWinMemoryStatusEx MemoryStatusInfo
70275>>>>>        tWinMemoryStatusEx MemoryStatusInfo
70275>>>>>        Integer iRetval
70275>>>>>        
70275>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
70276>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
70277>>>>>        If (iRetval = 0) Begin
70279>>>>>            Move (ShowLastError ()) to iRetval
70280>>>>>        End
70280>>>>>>
70280>>>>>        
70280>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, MemoryStatusInfo.ullTotalPhys))
70281>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, MemoryStatusInfo.dwMemoryLoad))
70282>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Integer ( Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0)))
70283>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Integer ( Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0)))
70284>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Integer ( Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0)))
70285>>>>>    End_Procedure
70286>>>>>    
70286>>>>>    Procedure Show_Registration
70288>>>>>        String sRegName
70288>>>>>        Integer iSN iMaxUsers
70288>>>>>        
70288>>>>>        Registration sRegName iSN
70289>>>>>>
70289>>>>>        
70289>>>>>        Get_Licensed_Max_Users to iMaxUsers
70290>>>>>        
70290>>>>>        Send AppendTextLn ""
70291>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
70292>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
70293>>>>>        Send AppendTextLn (SFormat (C_$MaxNumUsers, iMaxUsers))
70294>>>>>    End_Procedure
70295>>>>>    
70295>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
70295>>>>>    // To the workspace object passing the an object and message To send back
70295>>>>>    // To this object. It is expected that the workspace object will send this
70295>>>>>    // message for every line Of information it wants displayed (passing the
70295>>>>>    // information To be displayed
70295>>>>>    Register_Procedure EnumerateWorkspaceData Handle hObjId Handle hmMessId
70295>>>>>    
70295>>>>>    Procedure Show_ServicePack
70297>>>>>        String sKey sVersionDescription sVersion
70297>>>>>        Handle hoRegistry
70297>>>>>        Boolean bExists bOpened
70297>>>>>        
70297>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
70298>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
70299>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
70300>>>>>        
70300>>>>>        Move C_DFVersionRegistryRoot to sKey
70301>>>>>        Get KeyExists of hoRegistry sKey to bExists
70302>>>>>        If (bExists) Begin
70304>>>>>            Get OpenKey of hoRegistry sKey to bOpened
70305>>>>>            If (bOpened) Begin
70307>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
70308>>>>>                If (bExists) Begin
70310>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersionDescription
70311>>>>>                End
70311>>>>>>
70311>>>>>                
70311>>>>>                Get ValueExists of hoRegistry "CurrentVersion" to bExists
70312>>>>>                If (bExists) Begin
70314>>>>>                    Get ReadString of hoRegistry "CurrentVersion" to sVersion
70315>>>>>                End
70315>>>>>>
70315>>>>>                Send CloseKey of hoRegistry
70316>>>>>            End
70316>>>>>>
70316>>>>>        End
70316>>>>>>
70316>>>>>        Send Destroy of hoRegistry
70317>>>>>        
70317>>>>>        If (sVersionDescription <> "") Begin
70319>>>>>            Send AppendTextLn (sVersionDescription * "-" * sVersion)
70320>>>>>            Send AppendTextLn ""
70321>>>>>        End
70321>>>>>>
70321>>>>>    End_Procedure
70322>>>>>    
70322>>>>>    
70322>>>>>    Procedure Show_WorkspaceInformation
70324>>>>>        Integer hoWorkspace
70324>>>>>        
70324>>>>>        If (ghoApplication <> 0) Begin
70326>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
70327>>>>>            If (hoWorkspace <> 0) Begin
70329>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self (Refproc (AppendTextLn))
70330>>>>>                Send AppendTextLn ""
70331>>>>>            End
70331>>>>>>
70331>>>>>        End
70331>>>>>>
70331>>>>>    End_Procedure
70332>>>>>    
70332>>>>>    // If connection ids are used, we will send the message EnumerateConnections
70332>>>>>    // to the connection manager object passing the an object and message to send
70332>>>>>    // back to this object. It is expected that the connection manager object will
70332>>>>>    // send this message for every line Of information it wants displayed (passing
70332>>>>>    // the information To be displayed
70332>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
70332>>>>>    
70332>>>>>    Procedure Show_ConnectionIdInformation
70334>>>>>        If (ghoConnection > 0) Begin
70336>>>>>            Send AppendTextLn ""
70337>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
70338>>>>>        End
70338>>>>>>
70338>>>>>    End_Procedure
70339>>>>>    
70339>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
70341>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
70342>>>>>    End_Function
70343>>>>>    
70343>>>>>    Procedure Show_Versions
70345>>>>>        Integer iVersion iRevision iBuild
70345>>>>>        
70345>>>>>        Version_Information iVersion iRevision iBuild
70347>>>>>        
70347>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(Self,iVersion,iRevision,iBuild) ))
70348>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(Self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
70349>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(Self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
70350>>>>>    End_Procedure
70351>>>>>    
70351>>>>>    Procedure Show_Platform
70353>>>>>        Send AppendTextLn (SFormat (C_$Platform,"64-bit"))
70354>>>>>    End_Procedure
70355>>>>>    
70355>>>>>    Function CKRevisionNumber String sDriverID Returns String
70357>>>>>        Handle hoCLIHandler
70357>>>>>        Handle hoDFBtrDrvHandler
70357>>>>>        String sCKRevision
70357>>>>>        
70357>>>>>        
70357>>>>>        If (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV") Begin
70359>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLIHandler
70360>>>>>            Set psDriverID of hoCLIHandler to sDriverID
70361>>>>>            Move (CKRevision(hoCLIHandler)) to sCKRevision
70362>>>>>            Send Destroy of hoCLIHandler
70363>>>>>        End
70363>>>>>>
70363>>>>>        Else Begin
70364>>>>>            If (sDriverID = "DFBTRDRV") Begin
70366>>>>>                Get Create (RefClass(cDFBtrDrvHandler)) to hoDFBtrDrvHandler
70367>>>>>                Set psDriverID of hoDFBtrDrvHandler to sDriverID
70368>>>>>                Move (CKRevision(hoDFBtrDrvHandler)) to sCKRevision
70369>>>>>                Send Destroy of hoDFBtrDrvHandler
70370>>>>>            End
70370>>>>>>
70370>>>>>        End
70370>>>>>>
70370>>>>>        
70370>>>>>        Function_Return sCKRevision
70371>>>>>    End_Function
70372>>>>>    
70372>>>>>    
70372>>>>>    Function IsDataAccessCK String sDriverID Returns Boolean
70374>>>>>        
70374>>>>>        If (sDriverID = "DATAFLEX") Begin
70376>>>>>            Function_Return False
70377>>>>>        End
70377>>>>>>
70377>>>>>        
70377>>>>>        Function_Return (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV" or sDriverID = "DFBTRDRV")
70378>>>>>    End_Function
70379>>>>>    
70379>>>>>    
70379>>>>>    Procedure Show_Drivers
70381>>>>>        String sCurrentDriver sRevNumber
70381>>>>>        String sLoadedDrivers sClientDriver
70381>>>>>        Integer iNumberOfDrivers iCount iClientVersion iMSSQLIndex
70381>>>>>        Boolean bOK
70381>>>>>        Handle hoMsqlDrv
70381>>>>>        
70381>>>>>        Move "" to sLoadedDrivers
70382>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
70385>>>>>        For iCount from 1 to iNumberOfDrivers
70391>>>>>>
70391>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
70394>>>>>            If (sLoadedDrivers <> "") Begin
70396>>>>>                Move (Append (sLoadedDrivers, ", ")) to sLoadedDrivers
70397>>>>>            End
70397>>>>>>
70397>>>>>            Get IsDataAccessCK sCurrentDriver to bOK
70398>>>>>            If (bOK) Begin
70400>>>>>                If (sCurrentDriver = "MSSQLDRV") Begin
70402>>>>>                    Move iCount to iMSSQLIndex
70403>>>>>                End
70403>>>>>>
70403>>>>>                Get CKRevisionNumber sCurrentDriver to sRevNumber
70404>>>>>                // if mssqldrv, show the client number
70404>>>>>                Move (sCurrentDriver * "(" + sRevNumber + ")") to sCurrentDriver
70405>>>>>            End
70405>>>>>>
70405>>>>>            Move (Append (sLoadedDrivers, sCurrentDriver)) to sLoadedDrivers
70406>>>>>        Loop
70407>>>>>>
70407>>>>>        Send AppendTextLn (SFormat (C_$DatabaseDriver, sLoadedDrivers))
70408>>>>>        If (iMSSQLIndex>0) Begin
70410>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iMSSQLIndex to iClientVersion
70413>>>>>            Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
70414>>>>>            Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
70415>>>>>            Send Destroy of hoMsqlDrv
70416>>>>>            Send AppendTextLn (SFormat("MSSQLDRV Client Version: %1", sClientDriver))
70417>>>>>        End
70417>>>>>>
70417>>>>>    End_Procedure
70418>>>>>    
70418>>>>>    Procedure Show_HelpFile
70420>>>>>        String sHelpFile
70420>>>>>        Integer eHelpType
70420>>>>>        
70420>>>>>        If (ghoApplication <> 0) Begin
70422>>>>>            Get peHelpType of ghoApplication to eHelpType
70423>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
70425>>>>>                Get GetHelpFile of ghoHtmlHelp to sHelpFile
70426>>>>>            End
70426>>>>>>
70426>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
70429>>>>>                Get Help_filename of Help_object_id to sHelpFile
70430>>>>>            End
70430>>>>>>
70430>>>>>            Else Begin
70431>>>>>                Move C_$ThereIsNoHelpfileDefined to sHelpFile
70432>>>>>            End
70432>>>>>>
70432>>>>>            
70432>>>>>            Send AppendTextLn ""
70433>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
70434>>>>>        End
70434>>>>>>
70434>>>>>    End_Procedure
70435>>>>>    
70435>>>>>    Procedure Show_EnterAsTab
70437>>>>>        Boolean bEnterKeyAsTabKey
70437>>>>>        String sText
70437>>>>>        
70437>>>>>        If (ghoApplication <> 0) Begin
70439>>>>>            Get pbEnterKeyAsTabKey of ghoApplication to bEnterKeyAsTabKey
70440>>>>>            If (bEnterKeyAsTabKey) Begin
70442>>>>>                Move "True" to sText
70443>>>>>            End
70443>>>>>>
70443>>>>>            Else Begin
70444>>>>>                Move "False" to sText
70445>>>>>            End
70445>>>>>>
70445>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
70446>>>>>        End
70446>>>>>>
70446>>>>>    End_Procedure
70447>>>>>    
70447>>>>>    //    During activation we will remove the old information and add the newly
70447>>>>>    //    found systeminformation
70447>>>>>    Procedure Add_Focus Integer hoRoot
70449>>>>>        Forward Send Add_Focus hoRoot
70451>>>>>        
70451>>>>>        Send Delete_Data
70452>>>>>        
70452>>>>>        Set Changed_State to False
70453>>>>>        Set Read_Only_State to True
70454>>>>>        
70454>>>>>        Send Show_ServicePack
70455>>>>>        Send Show_Versions
70456>>>>>        Send Show_Platform
70457>>>>>        Send Show_Drivers
70458>>>>>        If (ghoConnection <> 0) Begin
70460>>>>>            Send Show_ConnectionIdInformation
70461>>>>>        End
70461>>>>>>
70461>>>>>        Send Show_HelpFile
70462>>>>>        Send Show_Current_Directory
70463>>>>>        Send Show_Filelist_Name
70464>>>>>        If (ghoApplication <> 0) Begin
70466>>>>>            Send Show_WorkSpaceInformation // added To show WS info
70467>>>>>        End
70467>>>>>>
70467>>>>>        Send Show_Current_User
70468>>>>>        Send Show_Windows_Directory
70469>>>>>        Send Show_Screen_Size
70470>>>>>        Send Show_Page_Size
70471>>>>>        Send Show_EnterAsTab
70472>>>>>        Send Show_Number_Format
70473>>>>>        Send Show_Date_Format
70474>>>>>        Send Show_Lock_Delay
70475>>>>>        Send Show_Lock_Timeout
70476>>>>>        Send Show_Date
70477>>>>>        Send Show_Systemresources
70478>>>>>        Send Show_Registration
70479>>>>>        Send Beginning_of_Data
70480>>>>>        
70480>>>>>        Set Icon to 'default.ico'
70481>>>>>    End_Procedure
70482>>>>>End_Class
70483>>>>>
70483>>>>>Class SysInfoDialog is a ModalPanel
70484>>>>>    Procedure Construct_Object
70486>>>>>        Forward Send Construct_Object
70488>>>>>        
70488>>>>>        Set Label to C_$SystemInformation
70489>>>>>        Set Size to 140 267
70490>>>>>        Set piMinSize to 140 267
70491>>>>>        Set Locate_Mode to CENTER_ON_SCREEN
70492>>>>>        Set Border_Style to Border_Thick
70493>>>>>        
70493>>>>>        Object oSysinfoDisplay is a SysInfoDisplay
70495>>>>>            Set peAnchors to anAll
70496>>>>>        End_Object
70497>>>>>        
70497>>>>>        Object oCloseButton is a Button
70499>>>>>            Set Label to C_$Close
70500>>>>>            Set Location to 120 210
70501>>>>>            Set Message 0 to (Refproc (Close_Panel))
70502>>>>>            Set Default_State to True
70503>>>>>            Set peAnchors to anBottomRight
70504>>>>>        End_Object
70505>>>>>        
70505>>>>>        On_Key kCancel Send Close_Panel
70506>>>>>    End_Procedure
70507>>>>>End_Class
70508>>>>>
70508>>>>>Class AboutDialog is a ModalPanel
70509>>>>>    Procedure Construct_Object
70511>>>>>        String sVdfRootDir
70511>>>>>        
70511>>>>>        Forward Send Construct_Object
70513>>>>>        
70513>>>>>        Set Label to C_$About
70514>>>>>        Set Size to 89 212
70515>>>>>        Set Locate_Mode to CENTER_ON_SCREEN
70516>>>>>        
70516>>>>>        Object oSysInfoDialog is a SysInfoDialog
70518>>>>>        End_Object
70519>>>>>        
70519>>>>>        Object oBox is a Container3d
70521>>>>>            Set Border_Style to Border_StaticEdge
70522>>>>>            Set Size to 63 202
70523>>>>>            Set Location to 4 5
70524>>>>>            
70524>>>>>            Object oAboutGraphic is a BitmapContainer
70526>>>>>                Set Border_Style to Border_None
70527>>>>>                Set Bitmap_Style to Bitmap_Center
70528>>>>>                Set Size to 48 48
70529>>>>>                Set Location to 7 2
70530>>>>>            End_Object
70531>>>>>            
70531>>>>>            Object oProductName is a TextBox
70533>>>>>                Set Label to C_$ProductName
70534>>>>>                Set Size to 10 45
70535>>>>>                Set Location to 8 53
70536>>>>>            End_Object
70537>>>>>            
70537>>>>>            Object oVersion is a TextBox
70539>>>>>                Set Label to C_$Version
70540>>>>>                Set Size to 10 25
70541>>>>>                Set Location to 21 53
70542>>>>>            End_Object
70543>>>>>            
70543>>>>>            Object oCopyright is a TextBox
70545>>>>>                Set Label to C_$Copyright
70546>>>>>                Set Size to 10 31
70547>>>>>                Set Location to 34 53
70548>>>>>            End_Object
70549>>>>>            
70549>>>>>            Object oAuthor is a TextBox
70551>>>>>                Set Label to C_$Author
70552>>>>>                Set Size to 10 22
70553>>>>>                Set Location to 46 53
70554>>>>>            End_Object
70555>>>>>        End_Object
70556>>>>>        
70556>>>>>        Object oOKButton is a Button
70558>>>>>            On_Item C_$OK Send Close_Panel
70559>>>>>            Set Size to 14 50
70560>>>>>            Set Location to 71 157
70561>>>>>        End_Object
70562>>>>>        
70562>>>>>        Object oSysInfoButton is a Button
70564>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
70565>>>>>            Set Size to 14 50
70566>>>>>            Set Location to 71 101
70567>>>>>        End_Object
70568>>>>>        
70568>>>>>        On_Key Kcancel Send KeyAction of oOKButton
70569>>>>>        
70569>>>>>        Set Logo to "DacAbout.bmp"  // square bitmaps Of 42x42 work best
70570>>>>>    End_Procedure
70571>>>>>    
70571>>>>>    Procedure Set ProductName String sProductName
70573>>>>>        Set Label of oProductName to sProductName
70574>>>>>    End_Procedure
70575>>>>>    
70575>>>>>    Procedure Set Version String sVersion
70577>>>>>        Set Label of oVersion to sVersion
70578>>>>>    End_Procedure
70579>>>>>    
70579>>>>>    Procedure Set Copyright String sCopyright
70581>>>>>        Set Label of oCopyright to sCopyright
70582>>>>>    End_Procedure
70583>>>>>    
70583>>>>>    Procedure Set Author String sAuthor
70585>>>>>        Set Label of oAuthor to sAuthor
70586>>>>>    End_Procedure
70587>>>>>    
70587>>>>>    Procedure Set Logo String sLogo
70589>>>>>        // square bitmaps Of 42x42 work best
70589>>>>>        Set Bitmap of oAboutGraphic to sLogo
70590>>>>>    End_Procedure
70591>>>>>    
70591>>>>>    Procedure Show_Sysinfo
70593>>>>>        Send Popup_Modal of oSysinfoDialog
70594>>>>>    End_Procedure
70595>>>>>    
70595>>>>>    Procedure End_Construct_Object
70597>>>>>        Handle hoVersionInfo
70597>>>>>        Boolean bIncluded
70597>>>>>        Integer iMajor iMinor iRelease iBuild
70597>>>>>        String sLabel
70597>>>>>        
70597>>>>>        Get Label of oVersion to sLabel
70598>>>>>        If (sLabel = C_$VERSION) Begin
70600>>>>>            // set it To the version info Of the program, if available
70600>>>>>            If (ghoApplication <> 0) Begin
70602>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
70603>>>>>                If (hoVersionInfo <> 0) Begin
70605>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
70606>>>>>                    If (bIncluded) Begin
70608>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
70609>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
70610>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
70611>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
70612>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
70613>>>>>                        Set Version to sLabel
70614>>>>>                    End
70614>>>>>>
70614>>>>>                End
70614>>>>>>
70614>>>>>            End
70614>>>>>>
70614>>>>>        End
70614>>>>>>
70614>>>>>        
70614>>>>>        Forward Send End_Construct_Object
70616>>>>>    End_Procedure
70617>>>>>End_Class
70618>>>
70618>>>//  This is the default message. It is expected that you will
70618>>>//  create your own message to override this
70618>>>Procedure Activate_About
70621>>>    Send DoAbout "" "" "" "" ""
70622>>>End_Procedure
70623>>>
70623>>>//  It is expected that you will send this message (most
70623>>>//  likely from Activate_About. This creates an about object, activates it
70623>>>//  and destroys it when done. It is not exepected that you will augment this.
70623>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap
70626>>>    Integer hoObj hoMain
70626>>>    
70626>>>    // create object
70626>>>    Object About is an AboutDialog
70628>>>        // if no title passed use the label of the main panel
70628>>>        // (if a main panel exists).
70628>>>        If (sTitle = "") Begin
70630>>>            Get Main_Window of desktop to hoMain
70631>>>            If hoMain ;                Get Label of hoMain to sTitle
70634>>>        End
70634>>>>
70634>>>        Set productname to sTitle
70635>>>        Set version     to sVersion
70636>>>        Set copyright   to sCopyRight
70637>>>        Set author      to sAuthor
70638>>>        If (sBitmap <> '') ;            Set logo to sBitMap // square bitmaps of 42x42 work best
70641>>>        Move Self to hoObj // object Id
70642>>>    End_Object
70643>>>    Send Popup   of hoObj    // popup the about object
70644>>>    Send Destroy of hoObj // when done, it will be destroyed
70645>>>End_Procedure
70646>>>
70646>        Use ScanFoto.vw
Including file: ScanFoto.vw    (C:\DataFlex Projects\Foto\AppSrc\ScanFoto.vw)
70646>>>Use Windows.pkg
70646>>>Use DFClient.pkg
70646>>>Use cSelectFolderDialog.pkg
Including file: cSelectFolderDialog.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cSelectFolderDialog.pkg)
70646>>>>>Use Windows.pkg
70646>>>>>
70646>>>>>External_Function SelectFolderDialog 'SelectFolderDialog' DfUtils.dll ;                                   Pointer lpwTitle ;                                   Pointer lpwInitialFolderName ;                                   Handle  hOwnerWindow ;                                   Returns Pointer
70647>>>>>
70647>>>>>// Provides an interface to the Windows folder selection dialog.
70647>>>>>Class cSelectFolderDialog is a cObject
70648>>>>>
70648>>>>>    Procedure Construct_Object
70650>>>>>        Forward Send Construct_Object
70652>>>>>        Property String  psTitle
70653>>>>>        Property String  psSelectedFolder
70654>>>>>        Property String  psInitialFolder
70655>>>>>        Property Boolean pbFolderIsSelected
70656>>>>>        Property Handle  phwParent        // needed to define the window to be modal
70657>>>>>    End_Procedure
70658>>>>>    
70658>>>>>    // Opens the Windows Select folder dialog and returns the selected folder
70658>>>>>    Function SelectFolder String sTitle String sInitialFolder Returns String
70660>>>>>        String sSelectedFolder
70660>>>>>        Boolean bFolderSelected
70660>>>>>        
70660>>>>>        Set psTitle         to sTitle
70661>>>>>        Set psInitialFolder to sInitialFolder
70662>>>>>        
70662>>>>>        // Execute the Select Folder Dialog
70662>>>>>        Get IsFolderSelected to bFolderSelected
70663>>>>>        
70663>>>>>        If bFolderSelected ;            Get psSelectedFolder to sSelectedFolder
70666>>>>>        
70666>>>>>        Function_Return sSelectedFolder
70667>>>>>    End_Function
70668>>>>>    
70668>>>>>    Function IsFolderSelected Returns Boolean
70670>>>>>        Handle  hParent
70670>>>>>        Integer iResult
70670>>>>>        String  szFolderName sTitle sInitialFolderName
70670>>>>>        Pointer lpwFolderName lpwInitialFolderName lpwTitle
70670>>>>>        Boolean bRetVal
70670>>>>>        WString wFolderName wInitialFolderName wTitle
70670>>>>>        
70670>>>>>        // Initialize the FolderName string.
70670>>>>>        Get psInitialFolder to sInitialFolderName
70671>>>>>        Move (Trim(sInitialFolderName))  to wInitialFolderName
70672>>>>>        Move (AddressOf(wInitialFolderName)) to lpwInitialFolderName
70673>>>>>                
70673>>>>>        // initialize the FolderName string.
70673>>>>>        Get psInitialFolder        to szFolderName
70674>>>>>        Move (Trim(szFolderName))  to szFolderName
70675>>>>>        Move (szFolderName + Repeat(Character(0), 500 - Length(szFolderName))) to wFolderName    // pad the folder name up to 500.
70676>>>>>        Move (AddressOf(wFolderName)) to lpwFolderName    // get address of this string
70677>>>>>
70677>>>>>        // Set the Title        
70677>>>>>        Get psTitle to sTitle
70678>>>>>        Move (Trim(sTitle))  to sTitle
70679>>>>>        If (sTitle = "") ;            Move "Select a folder" to sTitle
70682>>>>>        Move sTitle to wTitle
70683>>>>>        Move (AddressOf(wTitle)) to lpwTitle
70684>>>>>        
70684>>>>>        // Set the parent (or actually owner window) to make dialog modal. Set to NULL if it should not be modal.
70684>>>>>        Get phwParent to hParent
70685>>>>>        
70685>>>>>        Move (SelectFolderDialog(lpwTitle, lpwInitialFolderName, hParent)) to lpwFolderName
70686>>>>>        Move (PointerToWString(lpwFolderName)) to szFolderName
70687>>>>>
70687>>>>>        // Assign the selected folder name.
70687>>>>>        Set psSelectedFolder to (CString(szFolderName))
70688>>>>>        Set pbFolderIsSelected to (szFolderName <> "")
70689>>>>>        
70689>>>>>        Function_Return (szFolderName <> "")
70690>>>>>    End_Function
70691>>>>>        
70691>>>>>End_Class
70692>>>Use cTimer.pkg
Including file: cTimer.pkg    (C:\Program Files\DataFlex 20.0\Pkg\cTimer.pkg)
70692>>>>>// This supercedes the DFTimer class.
70692>>>>>// It is simpler and more flexible
70692>>>>>
70692>>>>>Use Dftimer.pkg // we still use the Timer Manager classes and global objects
Including file: Dftimer.pkg    (C:\Program Files\DataFlex 20.0\Pkg\Dftimer.pkg)
70692>>>>>>>Use LanguageText.pkg
70692>>>>>>>Use Windows.pkg
70692>>>>>>>Use WinUser.pkg
70692>>>>>>>
70692>>>>>>>External_Function SetTimer "SetTimer" User32.DLL ;    Handle  hWnd ;    Longptr idTimer ;    Integer idTimeout ;    Pointer tmprc ;    Returns Longptr     // return type is UINT_PTR
70693>>>>>>>
70693>>>>>>>External_Function KillTimer "KillTimer" User32.DLL ;    Handle  hWnd ;    Longptr idTimer ;    Returns Integer
70694>>>>>>>
70694>>>>>>>// This global integer holds the ID of the object
70694>>>>>>>// that manages all timers.
70694>>>>>>>Integer giTimerManager
70694>>>>>>>
70694>>>>>>>// This class is used to store the object IDs
70694>>>>>>>// of the active timer objects. It augments
70694>>>>>>>// the Destroy_Object procedure to notify
70694>>>>>>>// the DFTimerManager to kill all its active
70694>>>>>>>// timers.
70694>>>>>>>// NOTE: This class looks very much like the
70694>>>>>>>// Set class. I didn't want to use Set because
70694>>>>>>>// Remove_Element shifts items which I don't
70694>>>>>>>// want to happen because item numbers are used
70694>>>>>>>// as timerIDs.
70694>>>>>>>
70694>>>>>>>Class TimersArray is an Array
70695>>>>>>>    
70695>>>>>>>    Function Find_Object Integer iObj Returns Integer
70697>>>>>>>        Integer iMax
70697>>>>>>>        Integer iItem
70697>>>>>>>        Integer iValue
70697>>>>>>>        Get Item_count to iMax
70698>>>>>>>        Decrement iMax
70699>>>>>>>        For iItem from 1 to iMax
70705>>>>>>>>
70705>>>>>>>            Get Integer_Value iItem to iValue
70706>>>>>>>            If (iValue = iObj) ;                Function_Return iItem
70709>>>>>>>        Loop
70710>>>>>>>>
70710>>>>>>>        Function_Return -1
70711>>>>>>>    End_Function
70712>>>>>>>    
70712>>>>>>>    Procedure Add_Object Integer iObj Returns Integer
70714>>>>>>>        Integer iItem
70714>>>>>>>        Get Find_Object iObj to iItem
70715>>>>>>>        If (iItem < 0) Begin
70717>>>>>>>            Get Find_Object 0 to iItem
70718>>>>>>>            If (iItem < 0) ;                Get Item_Count to iItem
70721>>>>>>>        End
70721>>>>>>>>
70721>>>>>>>        Set Array_Value iItem to iObj
70722>>>>>>>        Procedure_Return iItem
70723>>>>>>>    End_Procedure
70724>>>>>>>    
70724>>>>>>>    Procedure Remove_Object Integer iObj
70726>>>>>>>        Integer iItem
70726>>>>>>>        Get Find_Object iObj to iItem
70727>>>>>>>        If (iItem > 0) ;            Set Array_Value iItem to 0
70730>>>>>>>    End_Procedure
70731>>>>>>>    
70731>>>>>>>    Procedure Destroy_Object
70733>>>>>>>        Delegate Send Kill_All_Timers
70735>>>>>>>        Forward Send Destroy_Object
70737>>>>>>>    End_Procedure
70738>>>>>>>    
70738>>>>>>>End_Class
70739>>>>>>>
70739>>>>>>>// This class is the actual timer manager
70739>>>>>>>// A timer will be created when Message Set_Timer_Active_State
70739>>>>>>>// has been send. This message needs two arguments. The first
70739>>>>>>>// is the objectID of the object to receive the timer event,
70739>>>>>>>// and the second is state. The object which ID has been passed,
70739>>>>>>>// needs to have a Timeout property to return the timeout for the
70739>>>>>>>// timer and it also needs to handle the MSG_OnTimer whenever a
70739>>>>>>>// timer event occurs.
70739>>>>>>>// The objectID of the Object will be placed in an array which contains
70739>>>>>>>// the objectIDs of all active timers. The Windows timer ID of a timer
70739>>>>>>>// is the itemnumber of the object in the array.
70739>>>>>>>//
70739>>>>>>>Class DFTimerManager is a DfBaseControl
70740>>>>>>>    
70740>>>>>>>    Procedure Construct_Object
70742>>>>>>>        
70742>>>>>>>        Forward Send Construct_Object
70744>>>>>>>        
70744>>>>>>>        Set Visible_State to False
70745>>>>>>>        
70745>>>>>>>        Set External_Class_Name "cVdfTimer" to "static"
70746>>>>>>>        Set External_Message WM_TIMER to OnTimer
70747>>>>>>>        
70747>>>>>>>        Object TimersArray is a TimersArray
70749>>>>>>>            Set Array_Value 0 to -9999 // So we don't use item 0
70750>>>>>>>        End_Object
70751>>>>>>>        
70751>>>>>>>        Move Self to giTimerManager
70752>>>>>>>        
70752>>>>>>>    End_Procedure
70753>>>>>>>    
70753>>>>>>>    Procedure Set Timer_Active_State Integer iObj Integer iState
70755>>>>>>>        Integer iTimerID
70755>>>>>>>        Integer iTimeout
70755>>>>>>>        Integer iResult
70755>>>>>>>        Integer iSet
70755>>>>>>>        DWord   nResult
70755>>>>>>>        Handle  hWnd
70755>>>>>>>        
70755>>>>>>>        // Get the handle of this object
70755>>>>>>>        Get Window_Handle to hWnd
70756>>>>>>>        If (not(hWnd)) Begin
70758>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
70759>>>>>>>>
70759>>>>>>>            Procedure_Return
70760>>>>>>>        End
70760>>>>>>>>
70760>>>>>>>        
70760>>>>>>>        // Test if handle is valid. If not, we leave.
70760>>>>>>>        If (not(IsWindow(hWnd))) ;            Procedure_Return
70763>>>>>>>        
70763>>>>>>>        Move (TimersArray(Self)) to iSet
70764>>>>>>>        
70764>>>>>>>        If (iSet) Begin
70766>>>>>>>            
70766>>>>>>>            // Let's create or modify a timer
70766>>>>>>>            If iState Begin
70768>>>>>>>                
70768>>>>>>>                // Get the exising to new TimerID
70768>>>>>>>                Get MSG_Add_Object of iSet iObj to iTimerID
70769>>>>>>>                
70769>>>>>>>                // Set/Modify the timer
70769>>>>>>>                Get Timeout of iObj to iTimeout
70770>>>>>>>                Move (SetTimer(hWnd, iTimerID, iTimeout, 0)) to iResult
70771>>>>>>>                If not iResult Begin
70773>>>>>>>                    Error DFERR_DFTIMER C_$TooManyTimers
70774>>>>>>>>
70774>>>>>>>                    Procedure_Return
70775>>>>>>>                End
70775>>>>>>>>
70775>>>>>>>                
70775>>>>>>>            End
70775>>>>>>>>
70775>>>>>>>            
70775>>>>>>>            // Let's kill an existing timer
70775>>>>>>>            Else Begin
70776>>>>>>>                
70776>>>>>>>                // Look up the object in the set
70776>>>>>>>                Get Find_Object of iSet iObj to iTimerID
70777>>>>>>>                
70777>>>>>>>                If (iTimerID = -1) ;                    Procedure_Return
70780>>>>>>>                
70780>>>>>>>                // Kill the timer
70780>>>>>>>                Move (KillTimer(hWnd, iTimerID)) to iResult
70781>>>>>>>                If not iResult Begin
70783>>>>>>>                    Move (GetLastError()) to nResult
70784>>>>>>>                    Error DFERR_DFTIMER (C_$CantKillTimer * String(nResult) - "!")
70785>>>>>>>>
70785>>>>>>>                    Procedure_Return
70786>>>>>>>                End
70786>>>>>>>>
70786>>>>>>>                
70786>>>>>>>                // Remove the objectID
70786>>>>>>>                Send Remove_Object to iSet iObj
70787>>>>>>>            End
70787>>>>>>>>
70787>>>>>>>        End
70787>>>>>>>>
70787>>>>>>>    End_Procedure
70788>>>>>>>    
70788>>>>>>>    Function Timer_Active_State Integer iObj Returns Integer
70790>>>>>>>        Integer iResult
70790>>>>>>>        Get Find_Object of (TimersArray(Self)) iObj to iResult
70791>>>>>>>        Function_Return (iResult<>-1) // note: -1= not found
70792>>>>>>>    End_Function
70793>>>>>>>    
70793>>>>>>>    // Will be called by the Set when it is being destroyed.
70793>>>>>>>    Procedure Kill_All_Timers
70795>>>>>>>        Integer iMax
70795>>>>>>>        Integer iSet
70795>>>>>>>        Integer iItem
70795>>>>>>>        Integer iObj
70795>>>>>>>        Integer iResult
70795>>>>>>>        Handle  hWnd
70795>>>>>>>        
70795>>>>>>>        // Get the handle of this object
70795>>>>>>>        Get Window_Handle to hWnd
70796>>>>>>>        If (not(hWnd)) Begin
70798>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
70799>>>>>>>>
70799>>>>>>>            Procedure_Return
70800>>>>>>>        End
70800>>>>>>>>
70800>>>>>>>        
70800>>>>>>>        // If the window handle is no longer valid, we
70800>>>>>>>        // leave this procedure. This can happen when the
70800>>>>>>>        // program is begin aborted using Exit_Application
70800>>>>>>>        If (not(IsWindow(hWnd))) ;            Procedure_Return
70803>>>>>>>        
70803>>>>>>>        // Scan the set and kill all known timers
70803>>>>>>>        Move (TimersArray(Self)) to iSet
70804>>>>>>>        If (iSet) Begin
70806>>>>>>>            Get Item_Count of iSet to iMax
70807>>>>>>>            Decrement iMax
70808>>>>>>>            For iItem from 1 to iMax
70814>>>>>>>>
70814>>>>>>>                Get Integer_Value of iSet iItem to iObj
70815>>>>>>>                If iObj Begin
70817>>>>>>>                    Move (KillTimer(hWnd, iItem)) to iResult
70818>>>>>>>                    Set Array_Value of iSet iItem to 0
70819>>>>>>>                End
70819>>>>>>>>
70819>>>>>>>            Loop
70820>>>>>>>>
70820>>>>>>>        End
70820>>>>>>>>
70820>>>>>>>        
70820>>>>>>>    End_Procedure
70821>>>>>>>    
70821>>>>>>>    Procedure OnTimer Longptr wParam Longptr lParam
70823>>>>>>>        Integer iObj
70823>>>>>>>        Get Integer_Value of (TimersArray(Self)) wParam to iObj
70824>>>>>>>        If not iObj Begin
70826>>>>>>>            Error DFERR_DFTIMER C_$TimerWithoutObject
70827>>>>>>>>
70827>>>>>>>            Procedure_Return
70828>>>>>>>        End
70828>>>>>>>>
70828>>>>>>>        Send OnTimer to iObj wParam lParam
70829>>>>>>>    End_Procedure
70830>>>>>>>    
70830>>>>>>>    Procedure Destroy_Object
70832>>>>>>>        Send Kill_All_Timers
70833>>>>>>>        Forward Send Destroy_Object
70835>>>>>>>        Move 0 to giTimerManager
70836>>>>>>>    End_Procedure
70837>>>>>>>    
70837>>>>>>>End_Class
70838>>>>>>>
70838>>>>>>>
70838>>>>>>>
70838>>>>>>>
70838>>>>>>>// This class acts as a container for the
70838>>>>>>>// timer manager object. This is needed because
70838>>>>>>>// A DFTimerManager object created directly at the
70838>>>>>>>// desktop doesn't have a Window_Handle which we
70838>>>>>>>// need to create a Windoows timer. By placing
70838>>>>>>>// this non-visual container around the timer
70838>>>>>>>// manager, it does get a Window_Handle.
70838>>>>>>>// The procedure End_Construct_Object has been
70838>>>>>>>// augmented to create a window and also
70838>>>>>>>// automatically page all children, which will
70838>>>>>>>// be the timer manager.
70838>>>>>>>//
70838>>>>>>>Class DFTimerManagerPanel is a dfBasePanel
70839>>>>>>>    
70839>>>>>>>    Procedure Construct_Object
70841>>>>>>>        Forward Send Construct_Object
70843>>>>>>>        Set Visible_State to False
70844>>>>>>>        Object DFTimerManager is a DFTimerManager
70846>>>>>>>        End_Object
70847>>>>>>>    End_Procedure
70848>>>>>>>    
70848>>>>>>>    Procedure End_Construct_Object
70850>>>>>>>        Forward Send End_Construct_Object
70852>>>>>>>        Send Page_Object True
70853>>>>>>>        Broadcast Send Page_Object True
70855>>>>>>>    End_Procedure
70856>>>>>>>    
70856>>>>>>>End_Class
70857>>>>>>>
70857>>>>>>>// This is the class the user uses to create DFTimer objects
70857>>>>>>>
70857>>>>>>>
70857>>>>>>>//{ OverrideProperty=Skip_State DesignTime=False }
70857>>>>>>>//{ OverrideProperty=TypeFace DesignTime=False }
70857>>>>>>>Class DFTimer is a Textbox
70858>>>>>>>    
70858>>>>>>>    Procedure Construct_Object
70860>>>>>>>        Forward Send Construct_Object
70862>>>>>>>        
70862>>>>>>>        // Make sure this object never appears
70862>>>>>>>        Set Visible_State to False
70863>>>>>>>        
70863>>>>>>>        Property Integer Private.Timeout    1000
70864>>>>>>>        
70864>>>>>>>        Property Integer Timer_Message      0
70865>>>>>>>        Property Integer Timer_Object       0
70866>>>>>>>        Property Integer Auto_Start_State   True
70867>>>>>>>        Property Integer Auto_Stop_State    True
70868>>>>>>>    End_Procedure
70869>>>>>>>    
70869>>>>>>>    Procedure Set Timer_Active_State Integer iState
70871>>>>>>>        Integer iObj
70871>>>>>>>        Move Self to iObj
70872>>>>>>>        If giTimerManager ;            Set Timer_Active_State of giTimerManager iObj to iState
70875>>>>>>>    End_Procedure
70876>>>>>>>    
70876>>>>>>>    Function Timer_Active_State Returns Integer
70878>>>>>>>        Integer iState
70878>>>>>>>        Integer iObj
70878>>>>>>>        Move Self to iObj
70879>>>>>>>        If giTimerManager ;            Get Timer_Active_State of giTimerManager iObj to iState
70882>>>>>>>        Function_Return iState
70883>>>>>>>    End_Function
70884>>>>>>>    
70884>>>>>>>    Procedure Set Timeout Integer iTimeout
70886>>>>>>>        Integer iActive
70886>>>>>>>        Set Private.Timeout to iTimeout
70887>>>>>>>        Get Timer_Active_State to iActive
70888>>>>>>>        If iActive ;            Set Timer_Active_State to True
70891>>>>>>>    End_Procedure
70892>>>>>>>    
70892>>>>>>>    Function Timeout Returns Integer
70894>>>>>>>        Integer iTimeout
70894>>>>>>>        Get Private.Timeout to iTimeout
70895>>>>>>>        Function_Return iTimeout
70896>>>>>>>    End_Function
70897>>>>>>>    
70897>>>>>>>    Procedure OnTimer Integer iwParam Integer ilParam
70899>>>>>>>        Integer iMsg
70899>>>>>>>        Integer iObj
70899>>>>>>>        Get Timer_Message to iMsg
70900>>>>>>>        If (iMsg) Begin
70902>>>>>>>            Get Timer_Object  to iObj
70903>>>>>>>            If iObj ;                Send iMsg to iObj iwParam ilParam
70906>>>>>>>            Else ;                Send iMsg iwParam ilParam
70908>>>>>>>        End
70908>>>>>>>>
70908>>>>>>>    End_Procedure
70909>>>>>>>    
70909>>>>>>>    // Augmented to Auto_Start a timer
70909>>>>>>>    //
70909>>>>>>>    Procedure Page_Object Integer iState
70911>>>>>>>        Forward Send Page_Object iState
70913>>>>>>>        If (iState and Auto_Start_State(Self)) ;            Set Timer_Active_State to True
70916>>>>>>>    End_Procedure
70917>>>>>>>    
70917>>>>>>>    // Augmented to Auto_Stop a timer
70917>>>>>>>    //
70917>>>>>>>    Procedure Page_Delete
70919>>>>>>>        If (Auto_Stop_State(Self)) ;            Set Timer_Active_State to False
70922>>>>>>>        Forward Send Page_Delete
70924>>>>>>>    End_Procedure
70925>>>>>>>    
70925>>>>>>>    // Augmented to stop the timer
70925>>>>>>>    //
70925>>>>>>>    Procedure Destroy_Object
70927>>>>>>>        Set Timer_Active_State to False
70928>>>>>>>        Forward Send Destroy_Object
70930>>>>>>>    End_Procedure
70931>>>>>>>    
70931>>>>>>>End_Class
70932>>>>>>>
70932>>>>>>>//
70932>>>>>>>// This was moved into a method so it can be reliable created
70932>>>>>>>// at the desktop. Note that cDesktop adds method to cDesktop class (class of desktop)
70932>>>>>>>//
70932>>>>>>>Procedure CreateDfTimerManagerPanel for cDesktop
70934>>>>>>>    // Create the Desktop Timer Manager Object.
70934>>>>>>>    Object DFTimerManagerPanel is a DFTimerManagerPanel
70936>>>>>>>    End_Object
70937>>>>>>>End_Procedure
70938>>>>>>>
70938>>>>>>>Send CreateDfTimerManagerPanel of DESKTOP
70939>>>>>
70939>>>>>Class cTimer is a cObject
70940>>>>>    
70940>>>>>    Procedure Construct_Object
70942>>>>>        Forward Send Construct_Object
70944>>>>>        Property Integer piPrivate_Timeout 1000
70945>>>>>    End_Procedure
70946>>>>>    
70946>>>>>    Procedure Set pbEnabled Boolean bEnabled
70948>>>>>        If giTimerManager Begin
70950>>>>>            Set Timer_Active_State of giTimerManager Self to bEnabled
70951>>>>>        End
70951>>>>>>
70951>>>>>    End_Procedure
70952>>>>>    
70952>>>>>    Function pbEnabled Returns Boolean
70954>>>>>        Boolean bEnabled
70954>>>>>        If giTimerManager Begin
70956>>>>>            Get Timer_Active_State of giTimerManager Self to bEnabled
70957>>>>>        End
70957>>>>>>
70957>>>>>        Function_Return bEnabled
70958>>>>>    End_Function
70959>>>>>    
70959>>>>>    Procedure Set piTimeout Integer iTimeout
70961>>>>>        Boolean bEnabled
70961>>>>>        Set piPrivate_Timeout to iTimeout
70962>>>>>        Get pbEnabled to bEnabled
70963>>>>>        If bEnabled Begin
70965>>>>>            Set pbEnabled to True
70966>>>>>        End
70966>>>>>>
70966>>>>>    End_Procedure
70967>>>>>    
70967>>>>>    Function piTimeout Returns Integer
70969>>>>>        Integer iTimeout
70969>>>>>        Get piPrivate_Timeout to iTimeout
70970>>>>>        Function_Return iTimeout
70971>>>>>    End_Function
70972>>>>>    
70972>>>>>    Procedure OnTimer
70974>>>>>    End_Procedure
70975>>>>>    
70975>>>>>    // this is needed by the timer manager
70975>>>>>    Function Timeout Returns Integer
70977>>>>>        Integer iTimeout
70977>>>>>        Get piPrivate_Timeout to iTimeout
70978>>>>>        Function_Return iTimeout
70979>>>>>    End_Function
70980>>>>>    
70980>>>>>    Procedure Destroy_Object
70982>>>>>        Set pbEnabled to False
70983>>>>>        Forward Send Destroy_Object
70985>>>>>    End_Procedure
70986>>>>>    
70986>>>>>End_Class
70987>>>
70987>>>Activate_View Activate_oScanFoto for oScanFoto
70997>>>>
70997>>>Object oScanFoto is a dbView
70999>>>
70999>>>    Set Border_Style to Border_Thick
71000>>>    Set Size to 68 300
71001>>>    Set Location to 2 2
71002>>>    Set Label to "Scan foto's"
71003>>>    Set pbAutoActivate to True
71004>>>    Set piMaxSize to 68 300
71005>>>    Set piMinSize to 68 300
71006>>>
71006>>>    Object oFotoVerwerker is a cTimer
71008>>>        Set pbEnabled to False
71009>>>        
71009>>>        Procedure OnTimer
71012>>>            String  sLocatie sFile sAlbum sTeller
71012>>>            Integer iChnl iTeller
71012>>>            Number  nTeller
71012>>>            Boolean bExist
71012>>>            
71012>>>            Get Value of oLocatie to sLocatie
71013>>>            Move (Trim(sLocatie)) to sLocatie
71014>>>            
71014>>>            Get Value of oAlbum   to sAlbum
71015>>>            Move (Trim(sAlbum))   to sAlbum
71016>>>            
71016>>>            Get Value of oTeller  to iTeller
71017>>>            Move iTeller          to nTeller
71018>>>            If ((nTeller / 2.0) = (iTeller / 2)) ;                Set Label of oInfo to "Scan achterkant"
71021>>>            Else ;                Set Label of oInfo to "Scan voorkant"
71023>>>                       
71023>>>            Get Seq_New_Channel to iChnl
71024>>>            
71024>>>            Direct_Input channel iChnl ("DIR:" + sLocatie + "\IMG*.jpg")
71026>>>            Readln channel iChnl sFile
71028>>>            While (not(SeqEof))
71032>>>                Move (Right("000"+String(iTeller), 3)) to sTeller
71033>>>                
71033>>>                File_Exist (sLocatie + "\" + sAlbum) bExist
71034>>>                If not (bExist) ;                    Make_Directory (sLocatie + "\" + sAlbum)
71037>>>
71037>>>                CopyFile (sLocatie + "\" + sFile) to (sLocatie + "\" + sAlbum + "\" + sAlbum + "-" + sTeller + ".jpg")
71038>>>>
71038>>>                Increment iTeller
71039>>>                Set Value of oTeller to iTeller
71040>>>                EraseFile (sLocatie + "\" + sFile)
71041>>>>
71041>>>                
71041>>>                Readln channel iChnl sFile
71043>>>            Loop
71044>>>>
71044>>>            Close_Input channel iChnl
71046>>>            
71046>>>            Send Seq_Release_Channel iChnl
71047>>>        End_Procedure
71048>>>    End_Object
71049>>>
71049>>>    Object oLocatie is a Form
71051>>>        Set Location to 5 65
71052>>>        Set Size to 12 229
71053>>>        Set Label to "Locatie:"
71054>>>        Set Prompt_Button_Mode to PB_PromptOn
71055>>>        Set Value to "C:\Fotoboek"
71056>>>        
71056>>>        Procedure Prompt
71059>>>            String sFolder
71059>>>            Handle hoDialog
71059>>>            
71059>>>            // dynically create a cSelectFolderDialog object
71059>>>            Get Create (RefClass(cSelectFolderDialog)) to hoDialog
71060>>>            
71060>>>            Get SelectFolder of hoDialog "Choose Folder" "C:\" to sFolder
71061>>>            If (sFolder <> "") ;                Set Value to  sFolder
71064>>>            Else ;                Send Info_Box "No Folder Selected"
71066>>>            
71066>>>            // destroy the dialog object
71066>>>            Send Destroy of hoDialog
71067>>>        End_Procedure
71068>>>    End_Object
71069>>>    
71069>>>    
71069>>>    Object oAlbum is a Form
71071>>>        Set Size to 12 229
71072>>>        Set Location to 19 65
71073>>>        Set Label to "Album:"
71074>>>    End_Object
71075>>>
71075>>>    Object oTeller is a Form
71077>>>        Set Size to 12 45
71078>>>        Set Location to 33 65
71079>>>        Set Label to "Teller"
71080>>>    End_Object
71081>>>
71081>>>    Object oInfo is a TextBox
71083>>>        Set Auto_Size_State to False
71084>>>        Set Size to 10 174
71085>>>        Set Location to 34 118
71086>>>        Set Label to ''
71087>>>    End_Object
71088>>>
71088>>>    Object oBtnStart is a Button
71090>>>        Set Location to 51 65
71091>>>        Set Label to "Start"
71092>>>    
71092>>>        // fires when the button is clicked
71092>>>        Procedure OnClick
71095>>>            Boolean bEnabled
71095>>>        
71095>>>            Get pbEnabled of oFotoVerwerker to bEnabled
71096>>>            If (bEnabled) Begin
71098>>>                Set Label to "Start"
71099>>>                Set pbEnabled of oFotoVerwerker to False
71100>>>                
71100>>>                Set Enabled_State of oLocatie to True
71101>>>                Set Enabled_State of oAlbum to True
71102>>>                Set Enabled_State of oTeller to True
71103>>>                Set Label of oInfo to ""
71104>>>            End
71104>>>>
71104>>>            Else Begin
71105>>>                Set Label to "Stop"
71106>>>                Set pbEnabled of oFotoVerwerker to True
71107>>>
71107>>>                Set Enabled_State of oLocatie to False
71108>>>                Set Enabled_State of oAlbum to False
71109>>>                Set Enabled_State of oTeller to False
71110>>>                Set Label of oInfo to ""
71111>>>            End
71111>>>>
71111>>>        End_Procedure
71112>>>    
71112>>>    End_Object
71113>>>
71113>>>
71113>>>End_Object
71114>        Use HernummerenFoto.vw
Including file: HernummerenFoto.vw    (C:\DataFlex Projects\Foto\AppSrc\HernummerenFoto.vw)
71114>>>Use Windows.pkg
71114>>>Use DFClient.pkg
71114>>>Use BatchDD.pkg
71114>>>
71114>>>Struct tFoto
71114>>>    Integer iTeller
71114>>>    String  sFile
71114>>>    Integer iNieuw
71114>>>    String  sFileNieuw
71114>>>End_Struct
71114>>>
71114>>>Deferred_View Activate_oHernummerenFoto for ;Object oHernummerenFoto is a dbView
71139>>>
71139>>>    Set Border_Style to Border_Thick
71140>>>    Set Size to 99 300
71141>>>    Set Location to 2 2
71142>>>    Set Label to "Hernummeren foto's"
71143>>>
71143>>>    Object oLocatie is a Form
71145>>>        Set Location to 5 65
71146>>>        Set Size to 12 229
71147>>>        Set Label to "Locatie:"
71148>>>        Set Prompt_Button_Mode to PB_PromptOn
71149>>>        Set Value to "C:\Fotoboek"
71150>>>        
71150>>>        Procedure Prompt
71153>>>            String sFolder
71153>>>            Handle hoDialog
71153>>>            
71153>>>            // dynically create a cSelectFolderDialog object
71153>>>            Get Create (RefClass(cSelectFolderDialog)) to hoDialog
71154>>>            
71154>>>            Get SelectFolder of hoDialog "Choose Folder" "C:\" to sFolder
71155>>>            If (sFolder <> "") ;                Set Value to  sFolder
71158>>>            Else ;                Send Info_Box "No Folder Selected"
71160>>>            
71160>>>            // destroy the dialog object
71160>>>            Send Destroy of hoDialog
71161>>>        End_Procedure
71162>>>    End_Object
71163>>>    
71163>>>    Object oAlbum is a Form
71165>>>        Set Size to 12 229
71166>>>        Set Location to 19 65
71167>>>        Set Label to "Album:"
71168>>>    End_Object
71169>>>
71169>>>    Object oTellerVan is a Form
71171>>>        Set Size to 12 37
71172>>>        Set Location to 33 65
71173>>>        Set Label to "Teller van:"
71174>>>    End_Object
71175>>>
71175>>>    Object oTellerTot is a Form
71177>>>        Set Size to 12 37
71178>>>        Set Location to 33 121
71179>>>        Set Label to "t/m:"
71180>>>        Set Label_Col_Offset to 0
71181>>>        Set Label_Justification_Mode to JMode_Right
71182>>>    End_Object
71183>>>
71183>>>    Object oInfo1 is a TextBox
71185>>>        Set Size to 10 64
71186>>>        Set Location to 56 7
71187>>>        Set Label to "Hernummeren naar"
71188>>>    End_Object
71189>>>
71189>>>    Object oNieuwVan is a Form
71191>>>        Set Size to 12 37
71192>>>        Set Location to 69 65
71193>>>        Set Label to "Teller van:"
71194>>>    End_Object
71195>>>
71195>>>    Object oBtnStart is a Button
71197>>>        Set Location to 83 65
71198>>>        Set Label to "Start"
71199>>>    
71199>>>        // fires when the button is clicked
71199>>>        Procedure OnClick
71202>>>            String sValue
71202>>>            
71202>>>            Get Value of oLocatie to sValue
71203>>>            Set psLocatie of oHernummerenProcess to sValue
71204>>>            
71204>>>            Get Value of oAlbum to sValue
71205>>>            Set psAlbum of oHernummerenProcess to sValue
71206>>>            
71206>>>            Get Value of oTellerVan to sValue
71207>>>            Set piTellerVan of oHernummerenProcess to sValue
71208>>>            
71208>>>            Get Value of oTellerTot to sValue
71209>>>            Set piTellerTot of oHernummerenProcess to sValue
71210>>>            
71210>>>            Get Value of oNieuwVan to sValue
71211>>>            Set piNieuwVan of oHernummerenProcess to sValue
71212>>>            
71212>>>            Send DoProcess to oHernummerenProcess
71213>>>        End_Procedure
71214>>>    
71214>>>    End_Object
71215>>>
71215>>>    Object oHernummerenProcess is a BusinessProcess
71217>>>    
71217>>>        Property String  psLocatie
71219>>>        Property String  psAlbum 
71221>>>        Property Integer piTellerVan
71223>>>        Property Integer piTellerTot
71225>>>        Property Integer piNieuwVan
71227>>>
71227>>>        Set Display_Error_State to True
71228>>>        Set Process_Title to "Hernummeren foto"
71229>>>        Set Process_Message to "Bestand"
71230>>>    
71230>>>        // Place your processing code into Procedure OnProcess
71230>>>        Procedure OnProcess
71233>>>            tFoto[] aFoto
71233>>>            tFoto[] aFoto
71234>>>            
71234>>>            Set Error_Count to 0
71235>>>            
71235>>>            Get ScanAlbum to aFoto
71236>>>            
71236>>>            Get InitHernummeren aFoto to aFoto
71237>>>            If (Error_Count(Self) > 0) ;                Procedure_Return
71240>>>            
71240>>>            Send Hernummeren aFoto
71241>>>        End_Procedure
71242>>>
71242>>>        Function SortFoto tFoto Array1 tFoto Array2 Returns Integer
71245>>>            If (Array1.iTeller > Array2.iTeller) Function_Return (GT)
71248>>>            If (Array1.iTeller < Array2.iTeller) Function_Return (LT)
71251>>>            Function_Return (EQ)
71252>>>        End_Function
71253>>>    
71253>>>        Function ScanAlbum Returns tFoto[]
71256>>>            Integer iTellerVan iTellerTot iPos iChnl iRow iTeller
71256>>>            String  sLocatie sAlbum sFile
71256>>>            tFoto[] aFoto
71256>>>            tFoto[] aFoto
71257>>>
71257>>>            Get psLocatie   to sLocatie
71258>>>            Get psAlbum     to sAlbum
71259>>>            Get piTellerVan to iTellerVan
71260>>>            Get piTellerTot to iTellerTot
71261>>>            
71261>>>            If (iTellerTot = 0) ;                Move 999 to iTellerTot
71264>>>            
71264>>>            Get Seq_New_Channel to iChnl
71265>>>            
71265>>>            Direct_Input channel iChnl ("DIR:" + sLocatie + "\" + sAlbum + "\*.jpg")
71267>>>            Readln channel iChnl sFile
71269>>>            While (not(SeqEof))
71273>>>                Move (Pos("-", sFile)) to iPos                
71274>>>                Move (Mid(sFile, 3, iPos+1)) to iTeller
71275>>>                
71275>>>                If ((iTeller >= iTellerVan) and (iTeller <= iTellerTot)) Begin
71277>>>                    Move (sLocatie + "\" + sAlbum + "\" + sFile)    to aFoto[iRow].sFile
71278>>>                    Move iTeller                                    to aFoto[iRow].iTeller
71279>>>                    Increment iRow
71280>>>                End
71280>>>>
71280>>>                
71280>>>                Readln channel iChnl sFile
71282>>>            Loop 
71283>>>>
71283>>>            Close_Input channel iChnl
71285>>>            
71285>>>            Send Seq_Release_Channel iChnl
71286>>>        
71286>>>            Move (SortArray(aFoto, Self, RefFunc(SortFoto))) to aFoto
71287>>>            Function_Return aFoto
71288>>>        End_Function
71289>>>        
71289>>>        Function InitHernummeren tFoto[] aFoto Returns tFoto[]
71292>>>            String  sLocatie sAlbum sFile
71292>>>            Integer iTellerVan iNieuwVan
71292>>>            Integer iRow iNumRow
71292>>>            Boolean bExist
71292>>>            
71292>>>            Get psLocatie   to sLocatie
71293>>>            Get psAlbum     to sAlbum
71294>>>            Get piTellerVan to iTellerVan
71295>>>            Get piNieuwVan  to iNieuwVan
71296>>>            
71296>>>            Move (SizeOfArray(aFoto) - 1) to iNumRow
71297>>>            for iRow from 0 to iNumRow
71303>>>>
71303>>>                Move (aFoto[iRow].iTeller - iTellerVan + iNieuwVan) to aFoto[iRow].iNieuw
71304>>>                
71304>>>                Move (sLocatie + "\" + sAlbum + "\" + sAlbum + "-" + Right("000"+String(aFoto[iRow].iNieuw), 3) + ".jpg") to sFile
71305>>>                File_Exist sFile  bExist
71306>>>                If (bExist) ;                    Send UserError ('"' + sFile + '" bestaat al, hernummeren afgebroken.')
71309>>>                Else ;                    Move sFile to aFoto[iRow].sFileNieuw
71311>>>            Loop
71312>>>>
71312>>>            
71312>>>            Function_Return aFoto
71313>>>        End_Function
71314>>>        
71314>>>        Procedure Hernummeren tFoto[] aFoto
71317>>>            String  sLocatie sAlbum sFile
71317>>>            Integer iRow iNumRow
71317>>>            Boolean bExist
71317>>>
71317>>>            Get psLocatie   to sLocatie
71318>>>            Get psAlbum     to sAlbum
71319>>>
71319>>>            Move (SizeOfArray(aFoto) - 1) to iNumRow
71320>>>            For iRow from 0 to iNumRow
71326>>>>
71326>>>                Send Update_Status aFoto[iRow].sFile
71327>>>                
71327>>>                CopyFile aFoto[iRow].sFile to aFoto[iRow].sFileNieuw
71328>>>>
71328>>>                File_Exist aFoto[iRow].sFileNieuw bExist
71329>>>                If (bExist) ;                    EraseFile aFoto[iRow].sFile
71332>>>            Loop
71333>>>>
71333>>>        End_Procedure
71334>>>    
71334>>>    End_Object
71335>>>
71335>>>Cd_End_Object
71337>>>>
71337>
71337>        Procedure Activate_About
71340>            Send DoAbout "" "" "" "" ""
71341>        End_Procedure
71342>
71342>    End_Object
71343>
71343>End_Object
71344>
71344>Start_UI
71345>
Summary
Memory Available: 7551946752
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 41634
Total Resources: 0
Total Commands : 71344
Total Windows  : 0
Total Pages    : 0
Static Data    : 483365
Message area   : 502653
Total Blocks   : 26829
